% !TeX root = ./pf2021.tex

%\includeonlyframes{current}

\begin{frame}{The language of a computer}
  \begin{itemize}[<+->]
  \item A \textit{computer} is a device that executes programs
  \item A \textit{program} is a collection of instructions to perform a specific
    task
  \item For a computer to understand instructions, these need to be expressed in a
    language that the computer can understand
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Binary language}

\begin{semiverbatim}
{\color{gray}\tikzref{markbit}0010\tikzref{markbyte}1001110110011000011111010111001011100111101100
11101000101001101011100111111100011101001000011010
00000110001101000011111010010001000101110000010010
00111011010111101101111110110011011111101100101101
10010010110011001101110011000011001011000001010010
11110100101111010001111001011000000000001111110100
1001110101100011010100\tikzref{ins}011100000001\tikzref{ins2}11000011\tikzref{ins3}01001101
00010001111001101000111100100110110110001101100100
01000110010111100011100010100101011011000110010001
10100011111101101000000000111101000001000100101101
11101100011010111001111110010101010110010010000100
00000010010011111010111011011101110011101100000111
00001001111011000000110000100110000101000100111011}\end{semiverbatim}

\uncover<2->{
  \uncover<2->{\tikz[overlay] \node[draw,rounded corners,thick,green,minimum
  width=3mm,minimum height=5mm,label={\color{green}bit}] (bit) at ([xshift=.5ex]markbit) {};}
  \uncover<3->{\tikz[overlay] \node[draw,rounded corners,thick,blue,minimum
  width=17mm,minimum height=7mm,label={45:{\color{blue}byte (8 bits)}}] (byte) at ([xshift=-.4ex]markbyte) {};}
  \uncover<4->{\tikz[overlay] \node[draw,rounded corners,thick,red,minimum width=49mm,minimum height=5mm] (instruction) at (ins) {};
  \tikz[overlay] \node[red] (description) at ([yshift=-32mm]instruction.south) {increment a number by 1 (for an x86_64)};
  \tikz[overlay] \draw[<-,red,thick] (instruction) -- (description);}
}

\end{frame}

\begin{frame}[fragile]{Programming language}
  \begin{itemize}
  \item<1-> A (high-level) programming language is an artificial language to write
    programs that is closer to humans
    \begin{columns}
      \begin{column}{.5\textwidth}
    \begin{codeblock}
int increment(int n)
\{
  return n + 1;
\}\end{codeblock}        
      \end{column}
      \begin{column}{.5\textwidth}
        {\smaller More or less equivalent to the function}
        \[
          \verb|increment|(n) = n + 1 \quad \forall n \in \mathbb{Z}
        \]
      \end{column}
    \end{columns}
\item<2-> Some form of translation needs to be applied to the program written in a
  high-level language to transform it into a program expressed in a binary
  language
\item<3-> To complicate things, the binary language is architecture-specific
  \begin{itemize}[<.->]
  \item Many architectures (Instruction Set Architectures -- ISA) have been
    defined over the years, many still in use
  \item i386, \textbf{x86_64}, SPARC, MIPS, \textbf{ARM}, VAX, Alpha, RiscV,
    PowerPC, \ldots
  \end{itemize}
\item<4-> The translation is done by other programs, notably \alert{compilers} and
  interpreters
\end{itemize}

\end{frame}

\begin{frame}{C++}

  \begin{itemize}[<+->]
  \item There are many programming languages, with very different characteristics
  \item Why \Cpp{}?
    \begin{itemize}[<.->]
    \item general purpose
    \item support for multiple styles of programming (\textit{paradigms})
    \item much used in scientific fields, but also in games, finance,
      telecommunications, embedded, \ldots
    \item available on all platforms
    \item efficient
    \item ISO standard
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Many types of computers}

  \begin{columns}

    \begin{column}{.5\textwidth}

      \includegraphics[width=\textwidth]{images/samsung-gear-compressed.jpeg}

      \begin{center}
        {\tiny(from \url{https://www.samsung.com/})}
      \end{center}
    \end{column}

    \begin{column}{.5\textwidth}
      \includegraphics[width=\textwidth]{images/gear2-ifixit.jpg}

      \begin{center}
        {\tiny (from \url{https://www.ifixit.com/})}
      \end{center}
    \end{column}

  \end{columns}

\end{frame}

\begin{frame}{Many types of computers \insertcontinuationtext}
  \includegraphics[width=\textwidth]{images/rpi-compressed.png}

  {\tiny (from \url{https://www.raspberrypi.org/})}
\end{frame}

\begin{frame}{Many types of computers \insertcontinuationtext}
  \includegraphics[width=\textwidth]{images/desktop.jpg}
\end{frame}

\begin{frame}{Many types of computers \insertcontinuationtext}
  \includegraphics[width=\textwidth]{images/fugaku.jpg}

  {\tiny (from \url{https://www.riken.jp/en/})}
\end{frame}

\begin{frame}[label=current]{The Von Neumann architecture}

  \begin{center}

    \vskip -.8cm

    \begin{tikzpicture}[every text node part/.style={align=center}]
      \uncover<3->{
        \node[rectangle,draw,thick,minimum height=4cm,minimum width=2.1cm,fill=yellow,"Memory"] (memory) {
          data \\ + \\ instructions
        };
        \node[above=20pt of memory,inner sep=0pt,outer sep=0pt] (ram) {\includegraphics[height=1cm]{images/ram.jpg}};
      }
      \uncover<2->{
        \node[rectangle,black,draw,thick,minimum height=4cm,minimum width=2.5cm,fill=red!80!black,right=of memory,"CPU"] (cpu) {};
        \node[rectangle,black,draw,thick,text width=2cm,minimum
        height=1cm,fill=white,below=10pt of cpu.north,inner sep=0pt,outer sep=0pt] (alu) {\scriptsize
          Arithmetic-Logic Unit};
        \node[rectangle,black,draw,thick,minimum width=2cm,fill=white,above=of cpu.south] (control) {\scriptsize Control};
        \path (alu) -- (control) node[midway,rectangle,black,draw,thick,minimum width=2cm,fill=white] (registers) {\scriptsize Registers};
        \node[above=20pt of cpu,inner sep=0pt,outer sep=0pt] (intel) {\includegraphics[height=1cm]{images/cpu.jpg}};
      }
      \uncover<3->{\draw[<->,thick] (memory) -- (cpu);}
      \uncover<4->{
        \node[tape,draw,thick,minimum height=1.5cm,minimum width=2cm,fill=green,right=of cpu.north east,yshift=-1cm] (input) {Input};
        \node[tape,draw,thick,minimum height=1.5cm,minimum width=2cm,fill=green,right=of cpu.south east,yshift=1cm] (output) {Output};
        \draw[<-,thick] (cpu) -- (input);
        \draw[->,thick] (cpu) -- (output);
        \node[above=of input,outer sep=0pt,inner sep=0pt] (keyboard) {\includegraphics[height=1cm]{images/keyboard.png}};
        \node[right=0pt of keyboard] (mouse) {\includegraphics[height=1cm]{images/mouse.jpg}};
        \node[below right=0pt and 0pt of mouse,xshift=-.5cm] (monitor) {\includegraphics[height=1cm]{images/monitor.png}};
        \node[below=0pt of monitor] (harddisk) {\includegraphics[height=1cm]{images/harddisk.jpg}};
        \node[below=0pt of harddisk] (usb-stick) {\includegraphics[height=1cm]{images/usb-stick.png}};
        \node[below=0pt of usb-stick] (router) {\includegraphics[height=1cm]{images/router.jpg}};
        \node[below left=0pt and 0pt of router] (gpu) {\includegraphics[height=1cm]{images/gpu.jpg}};
        \node[left=0pt of gpu] (sensor) {\includegraphics[height=1cm]{images/sensor.jpg}};
      }
    \end{tikzpicture}
  \end{center}

\end{frame}

\begin{frame}{The Von Neumann architecture \insertcontinuationtext}

  \begin{itemize}[<+->]
  \item Imagine memory as a looooong tape divided into locations whose content
    you can read and write
  \item Each memory location is identified by an index
    \begin{itemize}[<.->]
    \item e.g. location at position 8'363'944
    \end{itemize}
  \item Programs and the data they manage stay both in memory, typically in
    different regions
  \item The CPU fetches instructions from memory into its registers and executes
    them
  \item Typical instructions:
    \begin{itemize}[<.->]
    \item read data from memory into registers
    \item write data from registers to memory
    \item manipulate data in registers
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Also data are binary}

  \begin{semiverbatim}
{\color{gray}00101001110110011000011111010111001011100111101100
11101000101001101011100111111100011101001000011010
00000110001101000011111010010001000101110000010010
00111011010111101101111110110011011111101100101101
10010010110011001101110011000011001011000001010010
11110100101111010001111001011000000000001111110100
1001110110001101101001\tikzref{ins}0110000101101111000000001101
00010001111001101000111100100110110110001101100100
01000110010111100011100010100101011011000110010001
10100011111101101000000000111101000001000100101101
11101100011010111001111110010101010110010010000100
00000010010011111010111011011101110011101100000111
00001001111011000000110000100110000101000100111011}\end{semiverbatim}

\uncover<2->{
  \tikz[overlay] \node[draw,thick,rounded corners,red,minimum width=65mm,minimum
  height=5mm] (data) at (ins) {};
  \tikz[overlay] \node[red] (description) at ([yshift=-35mm]data.south)
  {\only<3>{integer number 1667850607?}\only<4>{floating-point
      number $4.30511 \times 10^{21}$?}\only<5>{character string "ciao"?}};
}

\end{frame}

\begin{frame}[fragile]{A minimal C++ program}

  \begin{itemize}
  \item This program does nothing, successfully (details will be explained)
    \begin{codeblock}
int main() \{\}\end{codeblock}

  \item<2-> Let's write these 13 characters (including spaces) in a
    \alert{source file}, which we call \code{minimal.cpp}

  \begin{shellblock}<3->{
\$\tikzref{prompt} \uncover<4->{code minimal.cpp\tikzref{command}} \uncover<5->{\inserthitenter\tikzref{hitnewline}}
\uncover<6->{\$ cat minimal.cpp \inserthitenter
int main() \{\}
\$}}\end{shellblock}

\uncover<3>{\tikz[remember picture,overlay] \draw[<-,white] ([xshift=1ex] prompt) -- +(1,0) node[white,right] {\scriptsize this is the shell prompt};}
\uncover<4>{\tikz[remember picture,overlay] \draw[<-,white] ([xshift=1ex] command) -- +(1,0) node[white,right] {\scriptsize this is the command you write};}
\uncover<5>{\tikz[remember picture,overlay] \draw[<-,white] ([xshift=1ex] hitnewline) -- +(1,0) node[white,right] {\scriptsize you hit the ``Enter'' key on the keyboard};}

  \item<7> Before \alert{executing} the program we need to translate it into
    the language of the computer
  
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{A minimal C++ program \insertcontinuationtext}

  \begin{itemize}

  \item In C++ the translation into a binary format is the job of the compiler,
    which produces an \alert{executable} file

\begin{center}
    \begin{tikzpicture}[every text node part/.style={align=center}]
      \node[tape,tape bend height=.3cm,draw,thick,inner sep=2pt,minimum height=2cm,minimum width=3cm] (source) {Source file \\ {\scriptsize(\code{minimal.cpp})}};
      \node[tape,tape bend height=.3cm,black,draw,thick, inner sep=2pt,minimum height=2cm,minimum width=3cm,right=3cm of source] (exe) {Executable binary file \\ {\scriptsize(\code{a.out})}};
      \draw[->] (source) -- (exe) node[above,align=center,midway] {Compilation \\ {\scriptsize(\code{g++})}};
    \end{tikzpicture}
  \end{center}

  \begin{shellblock}<2->{
\$ g++ minimal.cpp
\$ \uncover<3->{ls
a.out  minimal.cpp
\$ }\uncover<4->{./a.out\tikzref{program}
\$ }\uncover<5->{g++ minimal.cpp -o minimal
\$ ls
a.out  minimal  minimal.cpp
\$ }\uncover<6->{./minimal
\$ }}\end{shellblock}

  \uncover<4>{\tikz[remember picture,overlay] \draw[<-,white] ([xshift=1ex] program) -- +(1,0) node[white,right] {\scriptsize this command executes the program};}

  \item<7-> The \code{-o} option passed to the \code{g++} command allows to give
    another name to the final executable
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Spaces}

  \begin{itemize}
  \item Spaces are (almost) irrelevant
  \end{itemize}

  \begin{columns}[T]
  \begin{column}{.3\textwidth}<2->
    \begin{codeblock}
int main()\{\}

\end{codeblock}
  \end{column}

  \begin{column}{.3\textwidth}<3->
    \begin{codeblock}
int
main(  ) \{
   \}\end{codeblock}
  \end{column}

  \begin{column}{.3\textwidth}<4->
    \begin{codeblock}
int\tikzref{n1}main()\{ \}

    \end{codeblock}
  \end{column}

  \uncover<5->{
\begin{tikzpicture}[remember picture,overlay]
  \node[circle,radius=7pt,draw,red,line width=1pt,opacity=.7] at (n1) (n2){};
  \node[above=of n2,draw=red,line width=1pt,opacity=.7,rounded corners] {space needed here} edge[->,line width=1pt,red,opacity=.7] (n2);
\end{tikzpicture}
  }

\end{columns}

\begin{itemize}[<6->]
\item Tools exist to consistently format source code to improve readability
  \begin{itemize}
  \item They are customizable
  \item You are required to use them
  \end{itemize}
\end{itemize}

\begin{columns}[T]
  \begin{column}{.4\textwidth}
    \begin{shellblock}<7->{
\$ clang-format minimal.cpp
int main()
\{
\}
\$}\end{shellblock}
  \end{column}

  \begin{column}{.6\textwidth}
  \begin{codeblock}<8->{
# .clang-format file
\ldots
AllowShortFunctionsOnASingleLine: false
BraceWrapping:
  AfterFunction:   true
  \ldots}\end{codeblock}
  \end{column}
\end{columns}

\end{frame}

\begin{frame}[fragile]{Syntax check}

  \begin{itemize}
  \item The compiler can translate a program into a binary executable only if the
    code is syntactically correct

  \begin{codeblock}<2->{
intmain() \{\}}\end{codeblock}

  \begin{shellblock}<2->{
\$ g++ minimal.cpp
minimal.cpp:1:9: error: ISO C++ forbids declaration of \upquote{intmain} with \ldots
    1 | intmain() \{\}
      |         ^
\$}\end{shellblock}

  \item<3-> Error messages are usually precise about the cause of the error, but
    not always
  \item<3-> Learn to interpret error messages
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Comments}

  \begin{itemize}

  \item Code can contain comments

    \begin{codeblock}<2->{
int main() \alert{//} comment until the end of the line
\{
\}}\end{codeblock}

    \begin{codeblock}<3->{
int main()
\{
  \alert{/*} possibly multi-line comment
     that goes until the final marker
     and cannot nest \alert{*/}
\}}\end{codeblock}

  \item<4-> Comments are ignored by the compiler and are equivalent to spaces
  \item<4-> Comment are for humans
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Basic notions of Input and Output}

  \begin{itemize}
  \item The input and output system allows a program to interact with the
    external world
  \item One mechanism offered by C++ to do input and output is the \textit{I/O
      streams} interface, which allows the creation and the manipulation of
    \textit{stream} entities
    \begin{itemize}
    \item Values are extracted from an input stream
    \item Values are inserted into an output stream
    \end{itemize}
  \item Input and output streams connected to the terminal are automatically
    available to a program
    \begin{itemize}
    \item \code{std::cin}, \code{std::cout} (and \code{std::cerr} for errors)
    \end{itemize}
  \item To extract and insert values, use the stream \textit{operators}
    \code{>>} and \code{<<}, respectively
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Hello}

  A less minimal C++ program (details will be explained)

  \begin{codeblock}
\alert<2>{#include <iostream>}\uncover<2->{ // import I/O utilities}
\alert<2>{#include <string>}\uncover<2->{ // import string utilities}

int \alert<3>{main}()\uncover<3->{ // start the program from here}
\{
\alert<4>{  std::cout <{}< "What\textquotesingle{}s your name? ";}\uncover<4->{ // print a message on the terminal}
\alert<5>{  std::string name;}\uncover<5->{ // some space is needed in memory for a string}
\alert<6>{  std::cin >{}> name;}\uncover<6->{ // read a string from the terminal into that space}
\alert<7>{  std::cout <{}< "Hello, " <{}< name <{}< \bslashn{};}\uncover<7->{ // print a multi-part message}
\}\end{codeblock}

\begin{shellblock}<8->{
\uncover<8->{\$ g++ hello.cpp -o hello \inserthitenter
\$ }\uncover<9->{./hello \inserthitenter
What\textquotesingle{}s your name? }\uncover<10->{Francesco \inserthitenter
Hello, Francesco
\$ }}\end{shellblock}

\end{frame}

\begin{frame}{Objects}

  \begin{itemize}[<+->]
  \item The constructs in a C++ program create, destroy, refer to, access,
    and manipulate \alert<.>{objects}
  \item An object is a region of storage (i.e. memory)
    \begin{itemize}[<+->]
    \item has a \alert<.>{storage duration}/\alert<.>{lifetime}
    \item has a \alert<.>{type}
    \item can have a \alert<.>{name}
    \end{itemize}
  \end{itemize}

\end{frame}

\begin{frame}{Types}

  \begin{itemize}[<+->]
  \item A type gives meaning to a piece of storage
    \begin{itemize}
    \item What's the meaning of a piece of storage that contains $01100011011010010110000101101111$?
    \item Read as a sequence of alphabetic characters, it's the letters
      \textit{c}, \textit{i}, \textit{a}, \textit{o}
    \item Read as an integer number, it's $1667850607$
    \item Read as a floating-point number, it's about $4.30511 \times 10^{21}$
    \end{itemize}
  \item A type identifies a set of values and the operations that can be applied
    to those values
    \begin{itemize}
    \item C++ is a \alert{strongly typed} language (mostly)
    \end{itemize}
  \item The compiler checks that program instructions are compatible with the type system
    \begin{itemize}
    \item C++ is a \alert{statically typed} language (mostly)
    \end{itemize}
  \item A type is also associated with a machine representation for
    the values belonging to the type
  \item C++ defines a few fundamental types and provides mechanisms to build
    compound types on top of them
  \end{itemize}

\end{frame}

\begin{frame}{Fundamental types}
  \begin{itemize}
    \item arithmetic types
      \begin{itemize}
        \item integral types
          \begin{itemize}
          \item signed integer types: \code{short int}, \alert<3->{\code{int}},
            \code{long int}, \code{long long int}
          \item unsigned integer types: \code{unsigned short int},
            \code{unsigned int}, \code{unsigned long int}, \code{unsigned long
              long int}
          \item character types: \alert<3->{\code{char}}, \code{signed char},
            \code{unsigned char}, \ldots
          \item boolean types: \alert<3->{\code{bool}}
          \end{itemize}
        \item floating-point types: \code{float}, \alert<3->{\code{double}}, \code{long double}
      \end{itemize}
    \item \code{std::nullptr_t}
    \item \code{void}
  \end{itemize}

  \pause

  In general, size and machine representation are not defined by the
  standard

\end{frame}

\begin{frame}[fragile]{\code{int}}

  \begin{columns}
    \begin{column}{.8\textwidth}
      Type representing a signed integer number

      \begin{itemize}
      \item<2-> Set of values: subset of $\mathbb{Z}$
      \item<3-> Operations: addition, subtraction, multiplication, division,
        remainder, comparisons, \ldots
      \item<4-> Representation: 2's complement
      \item<5-> With N bits, values are in the range $[-2^{N-1}, 2^{N-1}-1]$
      \item<6-> Intended to have the natural size suggested by the architecture.
        Typical size is 32 bits (4 bytes)
        \begin{itemize}
        \item $[-2$ $147$ $483$ $648, +2$ $147$ $483$ $647]$
        \end{itemize}
      \end{itemize}
    \end{column}
    \hfill
    \begin{column}{.2\textwidth}
      \uncover<4->{\begin{tabular}{ r | r }
        7 & \alert{0}111 \\
        6 & \alert{0}110 \\
        5 & \alert{0}101 \\
        4 & \alert{0}100 \\
        3 & \alert{0}011 \\
        2 & \alert{0}010 \\
        1 & \alert{0}001 \\
        0 & \alert{0}000 \\
        -1 & \alert{1}111 \\
        -2 & \alert{1}110 \\
        -3 & \alert{1}101 \\
        -4 & \alert{1}100 \\
        -5 & \alert{1}011 \\
        -6 & \alert{1}010 \\
        -7 & \alert{1}001 \\
        -8 & \alert{1}000
      \end{tabular}}
    \end{column}
  \end{columns}

\end{frame}

\begin{frame}[fragile]{Variables}

  \begin{itemize}
  \item A variable is a \alert{name} for an \textit{object}
  \item A name is an \textit{identifier}: a sequence of letters (including
    \code{_}) and digits, starting with a letter
    \begin{itemize}
    \item Avoid \code{_} at the beginning
    \item Choose meaningful names
    \end{itemize}
  \end{itemize}

  \begin{codeblock}<2->{
\uncover<2->{int i;            // declaration}\uncover<3->{; the value is undefined}
\uncover<4->{i = 4321;         // assignment of a constant}
\uncover<5->{int j = 1234;     // declaration and initialization}
\uncover<6->{i = j;            // assignment of j\textquotesingle{}s value to i}}\end{codeblock}

  \begin{tikzpicture}[
      mem/.style={
        node font=\ttfamily\scriptsize,
        minimum height=.5cm,
      },
      location/.style={
        mem,
        draw=black!50,
        minimum width=1.2cm,
        fill=green!20!white,
      },
      every node/.style={
        mem,
      },
      anchor=south west,
      node distance=0,
    ]
    \clip (0.1,-1) rectangle (\textwidth-0.1cm,1.5);
    %% \visible<3->{\draw[step=.5cm,gray,thin,dashed] (0, .1cm) grid (\textwidth,0.4cm);}
    \visible<2->{\node at (0,0) [mem,draw=black!50,minimum width=\textwidth,
        "Memory" above] {};}
      \visible<2->{\node at (2,0) [location, "i" below] {
          \alt<-2>{}{\alt<3>{?}{\alt<4-5>{4321}{1234}}}};}
        \visible<5->{\node at (7,0) [location, "j" below] {1234};}
  \end{tikzpicture}

  \uncover<7->{NB At the end \code{i} and \code{j} have the same value but remain
  \alert{distinct} objects}

\end{frame}

\begin{frame}{Keywords}

  The following identifiers are reserved
  \vskip .5cm

  {
    \setbeamerfont{localfont}{size=\scriptsize,family=\tt}
    \usebeamerfont{localfont}

    \begin{tabular}{l l l l l l}
      alignas  & const        & for       & private          & throw    \\
      alignof  & constexpr    & friend    & protected        & true     \\
      and      & const_cast   & goto      & public           & try      \\
      and_eq   & continue     & if        & register         & typedef  \\
      asm      & decltype     & inline    & reinterpret_cast & typeid   \\
      auto     & default      & int       & return           & typename \\
      bitand   & delete       & long      & short            & union    \\
      bitor    & do           & mutable   & signed           & unsigned \\
      bool     & double       & namespace & sizeof           & using    \\
      break    & dynamic_cast & new       & static           & virtual  \\
      case     & else         & noexcept  & static_assert    & void     \\
      catch    & enum         & not       & static_cast      & volatile \\
      char     & explicit     & not_eq    & struct           & xor      \\
      char16_t & export       & nullptr   & switch           & xor_eq   \\
      char32_t & extern       & operator  & template         & wchar_t  \\
      class    & false        & or        & this             & while    \\
      compl    & float        & or_eq     & thread_local
    \end{tabular}
  }
\end{frame}

\begin{frame}{Literals}

  A literal is a constant \textbf{value} of a certain \textbf{type} included in
  the source code

  \pause

  \begin{itemize}
  \item integer
  \item floating point
  \item character
  \item string
  \item boolean
  \item \code{nullptr}
  \end{itemize}

\end{frame}

\begin{frame}{Integer literals}

  \begin{description}[<+->]
  \item[decimal] non-\code{0} decimal digit followed by zero or more digits
    \begin{itemize}[<.->]
    \item \code{1 -98 123456789 -1\textquotesingle{}234\textquotesingle{}567\textquotesingle{}890}
    \end{itemize}
  \item[binary] \code{0b} or \code{0B} followed by binary digits
    \begin{itemize}[<.->]
    \item \code{0b1101111010101101 0B111\textquotesingle{}0101\textquotesingle{}1011\textquotesingle{}1100\textquotesingle{}1101\textquotesingle{}0001\textquotesingle{}0101}
    \end{itemize}
  \item[exadecimal] \code{0x} or \code{0X} followed by hexadecimal digits
    \begin{itemize}[<.->]
    \item \code{-0xdead 0xDEad123f 0XdeAD\textquotesingle{}123F}
    \end{itemize}
  \item[octal] \code{0} followed by octal digits
    \begin{itemize}[<.->]
    \item \code{01 -077 07\textquotesingle{}654\textquotesingle{}321}
    \item N.B. A \code{0} in front of a number is meaningful!
    \end{itemize}
  \end{description}

  \uncover<+->{Integer literals are of type \code{int}}

\end{frame}

\begin{frame}[fragile]{\code{std::string}}

  \begin{itemize}[<+->]

  \item A \textit{compound} (\textit{user-defined}) type to represent a
    string of characters
  \item Provided by the C++ Standard Library
  \item Many operations available
  \item An \code{std::string} can be initialized with a string literal, a
    sequence of escaped or non-escaped characters between double quotes
    \begin{itemize}[<.->]
    \item \code{"hello" "hello\bslashn{}world" "hello
        \bslash{"}world\bslash{"}"}
    \item \code{\bslash{}n} means ``newline''
    \end{itemize}
  \item The type of a string literal is \textbf{not} \code{std::string}
  \end{itemize}

  \begin{codeblock}<+->{
std::string corso = "Programmazione per la Fisica";
\uncover<+->{corso = corso \tikzref{strplusref}+ "\bslash{n}Anno Accademico 2021/2022";}}\end{codeblock}

\uncover<+->{
  \begin{tikzpicture}[remember picture,overlay]
    \node[draw=red,line width=1pt,opacity=.7,rounded corners, minimum
    width=1.5ex] at ([xshift=.5ex]strplusref) (strplusbox) {};
    \node[below=of strplusbox,draw=red,line width=1pt,opacity=.7,rounded
    corners] {concatenate} edge[->,line width=1pt,red,opacity=.7] (strplusbox)
    {};
  \end{tikzpicture}
}

\end{frame}

\begin{frame}[fragile]{Expressions}

  \begin{itemize}
  \item An expression is a sequence of operators and their operands
    that specifies a computation
  \item Literals and variables are typical operands, but there are others

  \begin{codeblock}<2->{
\uncover<2->{1 + 2}
\uncover<3->{\alert<8->{i = 1 + 2}       // assignment}
\uncover<4->{i == j          // equality comparison}
\uncover<5->{sqrt(x) > 1.42}
\uncover<6->{\alert<8->{std::cout <{}< "hello, " <{}< name <{}< \upquote{\bslash{}n}}}}\end{codeblock}

\item<7-> The evaluation of an expression typically produces a result
\item<8-> Some expressions have \textit{side-effects}
  \begin{itemize}
  \item They modify the state of the program, i.e. the state of memory, or the
    external world
  \end{itemize}

\end{itemize}

\end{frame}

\begin{frame}[fragile]{Operators}

  \begin{columns}[t]

    \column{0.12\textwidth}
    {\scriptsize Arithmetic}
    \begin{codeblock}
+a
-a
a + b
a - b
a * b
a / b
a % b
~a
a & b
a | b
a ^ b
a {<}< b
a {>}> b\end{codeblock}

    \column{0.12\textwidth}
    \centering{\scriptsize Logical}
    \begin{codeblock}
!a
a && b
a || b\end{codeblock}

    \column{0.13\textwidth}
    \centering{\scriptsize Comparison}
    \begin{codeblock}
a == b
a != b
a {<} b
a {>} b
a {<}= b
a >= b\end{codeblock}

    \column{0.13\textwidth}
    \centering{\scriptsize Increment}
    \begin{codeblock}
++a
{-}-a
a++
a{-}-\end{codeblock}

    \column{0.14\textwidth}
    \centering{\scriptsize Assignments}
    \begin{codeblock}
a = b
a += b
a -= b
a *= b
a /= b
a %= b
a &= b
a |= b
a ^= b
a <{}<= b
a >{}>= b\end{codeblock}

    \column{0.09\textwidth}
    \centering{\scriptsize Access}
    \begin{codeblock}
a[b]
*a
&a
a->b
a.b\end{codeblock}

    \column{0.09\textwidth}
    \centering{\scriptsize Other}
    \begin{codeblock}
a(\ddd)
a, b
? :\end{codeblock}

  \end{columns}

  \vskip .5cm % bleah!

  Plus: casts, allocation and deallocation, static introspection, \ldots

  \begin{itemize}[<+->]
  \item Rules exist for associativity, commutativity and precedence
    \begin{itemize}
    \item When in doubt use parentheses
    \end{itemize}
  \item Many operators can be \alert{overloaded} for user-defined
    types
    \begin{itemize}[<.->]
    \item e.g. \code{+} to concatenate strings
    \end{itemize}
  \end{itemize}

\end{frame}

\begin{frame}{Algorithm}

  A finite sequence of precisely defined steps to solve a problem

\end{frame}

\begin{frame}<1-2>[fragile,label=firstexample]{Sum of two numbers}

  A program that reads two numbers from input and writes their sum to output

  \begin{columns}[T]
    \begin{column}{.5\textwidth}
      \centering
  \uncover<2->{
    \begin{tikzpicture}
      [auto,
      startstop/.style = {rectangle, rounded corners=5pt, draw=black, thick, node font=\scriptsize,
        text width=4em, align=flush center},
      inout/.style     = {trapezium, trapezium left angle=60,trapezium right angle=120, thick, draw=green, fill=green!20,
        text width=4em, align=flush center, node font=\scriptsize},
      block/.style     = {rectangle, draw=blue, thick, fill=blue!20,align=center, rounded corners=2pt,
        text width=4em, align=flush center, node font=\scriptsize},
      decision/.style  = {diamond, aspect=1.5, draw=red, thick, fill=red!20, text width=4em, align=flush center, inner sep=1pt, node font=\scriptsize},
      line/.style      = {draw, thick, -latex, shorten >=2pt}]
      \matrix [column sep=5mm,row sep=4mm]
      {
        % row 1
        \node [startstop] (start) {start}; \\
        % row 2
        \node [inout] (in) {read a, b}; \\
        % row 3
        \node [block,text width=7em] (result) {result $\leftarrow$ a + b}; \\
        % row 4
        \node [inout] (out) {write result}; \\
        % row 5
        \node [startstop] (stop) {stop}; \\
      };
      \begin{scope}[every path/.style=line]
        \path (start)  -- (in);
        \path (in)     -- (result);
        \path (result) -- (out);
        \path (out)    -- (stop);
      \end{scope}
    \end{tikzpicture}
  }
    \end{column}
    \begin{column}{.5\textwidth}
      \begin{codeblock}<3->{
#include <iostream>

int main()
\{
  \uncover<4->{\alert<4>{int a;
  int b;
  std::cin >{}> a >{}> b;}}
  \uncover<5->{\alert<5>{int result = a + b;}}
  \uncover<6->{\alert<6>{std::cout <{}< result <{}< \bslashn;}}
\}}\end{codeblock}

    \end{column}
  \end{columns}

  \uncover<7->{}
\end{frame}

\begin{frame}{Statement}
  Statements are units of code that are executed in sequence

  \begin{itemize}
  \item expression statement
  \item compound statement or block
  \item declaration statement
  \item selection statement
  \item iteration statement
  \item jump statement
  \item \ldots
  \end{itemize}

\end{frame}

\againframe<3->{firstexample}

\begin{frame}[fragile]{Expression statement}

  \begin{itemize}[<+->]
  \item An expression followed by a semicolon (\code{;})
  \item The value of the expression (if any) is discarded
  \item The expression can have side effects
  \end{itemize}

  \begin{codeblock}
\uncover<1->{b + 2;}
\uncover<3->{a = b + 2;
std::cin >{}> a >{}> b;}
\uncover<4->{; // empty statement}\end{codeblock}

\end{frame}

\begin{frame}[fragile]{Compound statement (or block)}

  A sequence of zero or more statements enclosed between braces
  (\code{\{\}})

  \begin{codeblock}
\{
   found = true;
   ++i;
   int n = 3;
   std::cout <{}< n;
\}\end{codeblock}

  \begin{codeblock}
\{ found = true; ++i; \ddd \} // all on one line\end{codeblock}

\end{frame}

\begin{frame}{Declaration statement}

  \begin{itemize}[<+->]
  \item A declaration statement introduces one or more new identifiers into a
    \Cpp{} program, possibly initializing them
    \begin{itemize}
    \item typically variables, but not only
    \end{itemize}

  \item A declaration of a \textbf{variable} in a \textbf{block} makes the
    variable of \alert{automatic storage duration}, unless otherwise specified
    \begin{itemize}
    \item the corresponding object is automatically created each time the
      declaration is executed
    \item<.-> the corresponding object is automatically destroyed each time the
      execution reaches the end of the block
    \end{itemize}

  \item A declaration should introduce only one identifier

  \item A variable should be declared only in the moment it's actually needed

  \item A variable should be initialized at the point of declaration, if there
    is a meaningful initial value

  \end{itemize}

\end{frame}

\begin{frame}[fragile]{The smallest of two numbers}

  A program that reads two numbers from input and writes the smallest to output

  \begin{columns}[T]
    \begin{column}{.5\textwidth}
  \uncover<2->{
    \begin{tikzpicture}
      [auto,
      startstop/.style = {rectangle, rounded corners=5pt, draw=black, thick, node font=\scriptsize,
        text width=3em, align=flush center},
      inout/.style     = {trapezium, trapezium left angle=60,trapezium right angle=120, thick, draw=green, fill=green!20,
        text width=4em, align=flush center, node font=\scriptsize},
      block/.style     = {rectangle, draw=blue, thick, fill=blue!20,align=center, rounded corners=2pt,
        text width=5em, align=flush center, node font=\scriptsize},
      decision/.style  = {diamond, aspect=1.5, draw=red, thick, fill=red!20, text width=4em, align=flush center, inner sep=1pt, node font=\scriptsize},
      line/.style      = {draw, thick, -latex, shorten >=2pt}]
      \matrix [column sep=0mm,row sep=4mm,ampersand replacement=\&]
      {
        % row
        \& \node [startstop] (start) {start}; \\
        % row
        \& \node [inout] (in) {read a, b}; \\
        % row
        \& \node [decision] (less) {a < b}; \\[-4mm]
        % row
        \node [block] (a) {result $\leftarrow$ a}; \&
        \& \node [block] (b) {result $\leftarrow$ b}; \\
        % row
        \& \coordinate (join); \\
        % row
        \& \node [inout] (out) {write result}; \\
        % row
        \& \node [startstop] (stop) {stop}; \\
      };
      \begin{scope}[every path/.style=line]
        \path (start)  -- (in);
        \path (in)     -- (less);
        \path (less)   -| node [near start,above] {\scriptsize{yes}} (a);
        \path (less)   -| node [near start,above] {\scriptsize{no}} (b);
        \path[-,shorten >=0pt] (a)   |- (join);
        \path[-,shorten >=0pt] (b)   |- (join);
        \path (join) -- (out);
        \path (out)    -- (stop);
      \end{scope}
    \end{tikzpicture}
  }
    \end{column}
    \begin{column}{.5\textwidth}
      \begin{codeblock}<3->{
#include <iostream>

int main()
\{
  \uncover<4->{\alert<4>{int a;
  int b;
  std::cin >{}> a >{}> b;}}
  \uncover<9->{\alert<9>{int result;}}
  \uncover<5->{\alert<5>{if (a < b) \{}
    \uncover<6->{\alert<6>{\only<-8>{int }result = a;}}
  \alert<5>{\} else \{}
    \uncover<6->{\alert<6>{\only<-8>{int }result = b;}}
  \alert<5>{\}}}
  \uncover<7->{\alert<7>{std::cout <{}< result <{}< \bslashn;}}\uncover<8>{\alert<8>{ // error}}
\}}\end{codeblock}

    \end{column}
  \end{columns}

  \uncover<10->{}

\end{frame}

\begin{frame}[fragile]{\code{if then else}}

  \begin{itemize}
  \item<1-> Selection statement to choose one of two flows of control depending on a
    boolean condition
  \item<2-> Two (basic) forms:
    \begin{itemize}
    \item<3-> \code{if (} \textit{condition-expr} \code{)} \textit{statement} \code{else} \textit{statement}
    \item<4-> \code{if (} \textit{condition-expr} \code{)} \textit{statement}
    \end{itemize}

  \begin{columns}[t]

    \begin{column}{.45\textwidth}

      \begin{codeblock}<3->{
\alert{if} (a < b) \{
  result = a;   // "true" branch
\} \alert{else} \{
  result = b;   // "false" branch
\}}\end{codeblock}

    \end{column}

    \begin{column}{.45\textwidth}
      \begin{codeblock}<4->{
int i = \ddd;
\alert{if} (i < 0) \{
  i = -i;   // "true" branch
\}}\end{codeblock}

    \end{column}

  \end{columns}

  \item<5-> \textit{condition-expr} can be any expression whose result is of type
    (convertible to) \code{bool}, i.e. either true or false

  \item<6-> \textit{statement} can be a block, possibly including multiple
    statements
    \begin{itemize}
    \item In fact, the statement should always be a block
    \end{itemize}
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{\code{bool}}

  Type representing a boolean value
  \begin{itemize}
  \item Set of values: ${false, true}$
  \item Operations: conjunction (\textit{and}), disjunction (\textit{or}),
    negation (\textit{not}), \ldots
  \item Size: typically $1$ byte
  \item Representation: like the \code{int}s \code{0} and \code{1}
  \item Literals: \code{false} and \code{true}

    \begin{codeblock}<2->{
\uncover<2->{bool b = true;}
\uncover<3->{b \tikzref{aref}= i =\tikzref{eref}= j;}
\uncover<6->{bool b2 = i !\tikzref{neref}= 1234;}
\uncover<7->{bool b3 = b2 \alert<7>{\&\&} i < j;    // and
bool b4 = i < j \alert<7>{||} i < k; // or
bool b5 = \alert<7>{!}\alert<8>{(}i == j\alert<8>{)};      // not}}\end{codeblock}

  \item<8-> Note the use of parenthesis in \code{!(i == j)} to have the right
    precedence of application of operators
  \end{itemize}

\uncover<4->{
  \begin{tikzpicture}[remember picture,overlay]
    \uncover<4-5>{
      \node[draw=red,line width=1pt,opacity=.7,rounded corners, minimum width=1.5ex] at ([xshift=.5ex]aref) (abox){};
      \node[below=of abox,draw=red,line width=1pt,opacity=.7,rounded corners] {assignment} edge[->,line width=1pt,red,opacity=.7] (abox);
    }
    \uncover<5>{
      \node[draw=red,line width=1pt,opacity=.7,rounded corners,minimum width=3ex] at (eref) (ebox){};
      \node[below right=of ebox.south east,draw=red,line width=1pt,opacity=.7,rounded corners] {equality} edge[->,line width=1pt,red,opacity=.7] (ebox);
    }
    \uncover<6>{
      \node[draw=red,line width=1pt,opacity=.7,rounded corners,minimum width=3ex] at (neref) (nebox){};
      \node[below=of nebox,draw=red,line width=1pt,opacity=.7,rounded corners] {inequality} edge[->,line width=1pt,red,opacity=.7] (nebox);
    }
  \end{tikzpicture}
}

\end{frame}

\begin{frame}{Logical operations}

  \begin{description}[<+->]

  \item[and] Both operands are true
    \vskip .5em
    {\scriptsize\begin{tabular}{ c c | c }
      op1 & op2 & op1 \textbf{\&\&} op2 \\
      \hline
      \code{false} & \code{false} & \code{false} \\
      \code{false} & \code{true} & \code{false} \\
      \code{true} & \code{false} & \code{false} \\
      \code{true} & \code{true} & \code{true} \\
    \end{tabular}}
    \vskip .5em

    \code{op2} is evaluated only if \code{op1} is \code{true}

  \item[or] At least one operand is true
    \vskip .5em

    {\scriptsize\begin{tabular}{ c c | c }
      op1 & op2 & op1 \textbf{||} op2 \\
      \hline
      \code{false} & \code{false} & \code{false} \\
      \code{false} & \code{true} & \code{true} \\
      \code{true} & \code{false} & \code{true} \\
      \code{true} & \code{true} & \code{true} \\
    \end{tabular}}
    \vskip .5em

    \code{op2} is evaluated only if \code{op1} is \code{false}

  \item[not] Operand's negation (or logical complement)
    \vskip .5em

    {\scriptsize\begin{tabular}{ c | c }
      op & \textbf{!}op \\
      \hline
      \code{false} & \code{true} \\
      \code{true}  & \code{false} \\
    \end{tabular}}
    \vskip .5em

  \end{description}

\end{frame}

\begin{frame}{Scope}

  The scope of a name appearing in a program is the, possibly
  discontiguous, portion of source code where that name is valid

  \begin{itemize}
  \item block scope
  \item function scope
  \item class scope
  \item namespace scope (including the global one)
  \item \ldots
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Block scope}

  \begin{itemize}[<+->]
  \item The scope of a name declared in a block starts at the point of
    declaration and ends at the \code{\}}

    \begin{codeblock}
\{
  \ddd
  int num;         // scope of num begins here
  std::cin >{}> num; // ok
\}                  // scope of num ends here
std::cout <{}< num;  // error\end{codeblock}

  \item<2-> The scope of a variable should be as small as possible
    \begin{itemize}
    \item Declare a variable only when it's needed
    \item If possible/meaningful, initialize it
    \end{itemize}
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Example: is a number even?}

  A program that reads a number from input and tells if it's even

  \begin{columns}[T]
    \begin{column}{.6\textwidth}
  \uncover<2->{
    \begin{tikzpicture}
      [auto,
      startstop/.style = {rectangle, rounded corners=5pt, draw=black, thick, node font=\scriptsize,
        text width=3em, align=flush center},
      inout/.style     = {trapezium, trapezium left angle=60,trapezium right angle=120, thick, draw=green, fill=green!20,
        text width=4em, align=flush center, node font=\scriptsize},
      block/.style     = {rectangle, draw=blue, thick, fill=blue!20,align=center, rounded corners=2pt,
        text width=5em, align=flush center, node font=\scriptsize},
      decision/.style  = {diamond, aspect=1.5, draw=red, thick, fill=red!20, text width=4em, align=flush center, inner sep=1pt, node font=\scriptsize},
      line/.style      = {draw, thick, -latex, shorten >=2pt}]
      \matrix [column sep=0mm,row sep=4mm,ampersand replacement=\&]
      {
        % row
        \& \node [startstop] (start) {start}; \\
        % row
        \& \node [inout] (in) {read num}; \\
        % row
        \& \node [block,text width=7em] (mod) {r $\leftarrow$ num \textit{mod} 2}; \\
        % row
        \& \node [decision] (iszero) {r == 0}; \\[-4mm]
        % row
        \node [block,text width=6em] (even) {result $\leftarrow$ true}; \&
        \& \node [block,text width=6em] (odd) {result $\leftarrow$ false}; \\
        % row
        \& \coordinate (join); \\
        % row
        \& \node [inout,text width=6em] (out) {write result}; \\
        % row
        \& \node [startstop] (stop) {stop}; \\
      };
      \begin{scope}[every path/.style=line]
        \path (start)  -- (in);
        \path (in)     -- (mod);
        \path (mod)    -- (iszero);
        \path (iszero) -| node [near start,above] {\scriptsize{yes}} (even);
        \path (iszero) -| node [near start,above] {\scriptsize{no}} (odd);
        \path[-,shorten >=0pt] (even) |- (join);
        \path[-,shorten >=0pt] (odd)  |- (join);
        \path (join) -- (out);
        \path (out)    -- (stop);
      \end{scope}
    \end{tikzpicture}
  }
    \end{column}

    \begin{column}{.4\textwidth}
      \begin{codeblock}<3->{
#include <iostream>

int main()
\{
\uncover<4->{\alert<4>{  int num;
  std::cin >{}> num;}}
\uncover<5->{\alert<5>{  int r = num \% 2;}}
\only<7-10>{\alert<7>{  bool result;}}\only<11->{  bool result \alert<11>{= r == 0};}
\only<6-10>{\alert<6>{  if (r == 0) \{}}
\only<7-10>{\alert<7>{    result = true;}}
\only<6-10>{\alert<6>{  \} else \{}}
\only<7-10>{\alert<7>{    result = false;}}
\only<6-10>{\alert<6>{  \}}}
\only<9>{  // print 0/1}\only<10>{  // print false/true}
\only<8-9>{\alert<8>{  std::cout <{}< result <{}< \bslashn;}}\only<10->{  std::cout <{}< \alert<10>{std::boolalpha}
      <{}< result <{}< \bslashn;}
\}}\end{codeblock}
    \end{column}

  \end{columns}

\end{frame}

\begin{frame}{Exercise: the smallest of three numbers}

  Write a program that reads three numbers from standard input and writes the
  smallest one to standard output

\end{frame}

\begin{frame}[fragile]{Integer square root}

  Write a program that computes the integer square root of a non-negative
  integer number, i.e. the largest integer number whose square is not greater
  than the given number

  \begin{columns}[T]
    \begin{column}{.5\textwidth}
      \uncover<2->{\begin{tikzpicture}
          [auto,
          startstop/.style = {rectangle, rounded corners=5pt, draw=black, thick, node font=\scriptsize,
            text width=3em, align=flush center},
          inout/.style     = {trapezium, trapezium left angle=60,trapezium right angle=120, thick, draw=green, fill=green!20,
            text width=4em, align=flush center, node font=\scriptsize},
          block/.style     = {rectangle, draw=blue, thick, fill=blue!20,align=center, rounded corners=2pt,
            text width=5em, align=flush center, node font=\scriptsize},
          decision/.style  = {diamond, aspect=1.5, draw=red, thick, fill=red!20, text width=4em, align=flush center, inner sep=1pt, node font=\scriptsize},
          line/.style      = {draw, thick, -Classical TikZ Rightarrow, shorten >=1pt}]
          \matrix [column sep=4mm,row sep=3mm,ampersand replacement=\&]
          {
            % row
            \& \node [startstop] (start) {start}; \\
            % row
            \& \node [inout] (in) {read $n$}; \\
            % row
            \& \node [block] (initi) {$i \gets 1$}; \\[-1mm]
            % row
            \& \coordinate (beforecond1); \\
            % row
            \node [block] (inc) {$i \gets i + 1$}; \& \node [decision] (cond1) {$i \times i < n$}; \\
            % row
            \node [block] (dec) {$i \gets i - 1$};
            \& \node [decision] (cond2) {$i \times i > n$}; \\[-1mm]
            % row
            \& \coordinate (aftercond2); \\
            % row
            \& \node [inout] (out) {write $i$}; \\
            % row
            \& \node [startstop] (stop) {stop}; \\
          };
          \begin{scope}[every path/.style=line]
            \path (start)  -- (in);
            \path (in)     -- (initi);
            \path (initi)  -- (cond1);
            \path (cond1)  -- node {\scriptsize{no}} (cond2);
            \path (cond1)  -- node {\scriptsize{yes}} (inc);
            \path (inc)    |- (beforecond1);
            \path (cond2)  -- node [near start] {\scriptsize{no}} (out);
            \path (cond2)  -- node {\scriptsize{yes}} (dec);
            \path (dec)    |- (aftercond2);
            \path (out)    -- (stop);
          \end{scope}
        \end{tikzpicture}}

    \end{column}

    \begin{column}{.5\textwidth}
      \begin{codeblock}<3->{
#include <iostream>

int main()
\{
  int n;
  std::cin >> n;
  int i = 1;
  while (i * i < n) \{
    ++i;   // equivalent to i = i + 1
  \}
  if (i * i > n) \{
    --i;   // equivalent to i = i - 1
  \}
  std::cout << i << \bslashn;
\}}\end{codeblock}
    \end{column}

  \end{columns}

\end{frame}

\begin{frame}[fragile]{\code{while} loop}

  \begin{center}
    \code{while (} \textit{condition-expr} \code{)} \textit{statement}
  \end{center}

  \pause

  \begin{itemize}[<+->]
  \item Execute repeatedly \textit{statement} until \textit{condition-expr}
    becomes false
  \item \textit{condition-expr} is evaluated at the beginning of each iteration
    \begin{itemize}
    \item If \textit{condition-expr} is already \code{false} at the beginning,
      \textit{statement} is never executed
    \end{itemize}
  \item \textit{statement} can be any statement, including of course a block
  \item \textit{statement} should modify something so that the evaluation of
    \textit{condition-expr} may change
    \begin{itemize}[<.->]
    \item Otherwise the loop may never terminate
    \end{itemize}
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Sum of the first N numbers}
  Write a program that reads a non-negative integer number N from standard
  input, computes the sum of the first N numbers and writes the result to
  standard output

  \begin{columns}[T]

    \begin{column}{.5\textwidth}
      \begin{codeblock}<2->{
#include <iostream>

int main()
\{
  int n;
  std::cin >{}> n;
  int sum = 0;
  \alert<3->{int i = 1;}
  while (\alert<3->{i <= n}) \{
    sum += i;   // sum = sum + i
    \alert<3->{++i};
  \}
  std::cout <{}< sum <{}< \bslashn;
\}}\end{codeblock}

    \end{column}

    \begin{column}{.5\textwidth}
      \begin{codeblock}<4->{
#include <iostream>

int main()
\{
  int n;
  std::cin >{}> n;
  int sum = 0;

  \textbf<4>{for} (\alert<4>{int i = 1}; \alert<4>{i <= n}; \alert<4>{++i}) \{
    sum += i;

  \}
  std::cout <{}< sum <{}< \bslashn;
\}}\end{codeblock}
    \end{column}

  \end{columns}
\end{frame}

\begin{frame}[fragile]{\code{for} loop}

  \code{for (} \textit{init-statement} \opt{\textit{condition-expr}} \code{;}
  \opt{\textit{expression}} \code{)} \textit{statement}

  \pause

  \begin{itemize}[<+->]
  \item Execute \textit{init-statement}, which may be a single \code{;}
    \begin{itemize}
    \item If \textit{init-statement} contains declarations (e.g. the \code{i}
      variable in the previous example), the scope of the declared names is
      the loop
    \end{itemize}
  \item Execute repeatedly \textit{statement} until \textit{condition-expr} becomes false
  \item \textit{condition-expr} is evaluated at the beginning of each iteration
    \begin{itemize}
    \item If \textit{condition-expr} is already false at the beginning,
      \textit{statement} is never executed
    \item But \textit{init-statement} is always executed
    \end{itemize}
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{\code{for} loop \insertcontinuationtext}

  \code{for (} \textit{init-statement} \opt{\textit{condition-expr}} \code{;}
  \opt{\textit{expression}} \code{)} \textit{statement}

  \pause

  \begin{itemize}[<+->]
  \item \textit{expression} is evaluated at the end of each iteration
  \item \textit{statement} and/or \textit{expression} should modify something so
    that the evaluation of \textit{condition-expr} may change
    \begin{itemize}[<.->]
    \item Otherwise the loop may never terminate
    \end{itemize}
  \item A \code{for} loop can always be transformed into a \code{while} loop and
    viceversa
    \begin{itemize}
    \item Prefer a \code{for} loop when there is an obvious loop variable
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Integer square root with a \code{for} loop}

  Write a program that computes the integer square root of a non-negative
  integer number, i.e. the largest integer number whose square is not greater
  than the given number

  \begin{columns}[T]
    \begin{column}{.35\textwidth}
      \begin{codeblock}
#include <iostream>

int main()
\{
  int n;
  std::cin >{}> n;
  int i = 1;
  while (i * i < n) \{
    ++i;
  \}
  if (i * i > n) \{
    --i;
  \}
  std::cout << i << \bslashn;
\}\end{codeblock}
    \end{column}

    \begin{column}{.65\textwidth}
      \begin{codeblock}<2->{
#include <iostream>

int main()
\{
  int n;
  std::cin >{}> n;
  \uncover<4->{int i = 1;}
  for (\alt<-3>{int i = 1}{ }; i * i < n; ++i) \alt<-5>{\{}{\alert<6>{;}}
    \only<-4>{;}
  \only<-5>{\}}
  if (\alert<3>{i} * \alert<3>{i} > n) \{\uncover<3>{ // \alert{error: undeclared variable}}
    --\alert<3>{i};
  \}
  std::cout << i << \bslashn;
\}}\end{codeblock}
    \end{column}

  \end{columns}

  \uncover<7>{}

\end{frame}

\begin{frame}{Exercise: the smallest of N numbers}

  Write a program that reads an arbitrary sequence of numbers from standard
  input and writes the smallest one to standard output

  Hint 1: press Ctrl-D to tell the program there is nothing more to read from
  standard input

  Hint 2: the expression \code{std::cin.good()} tells if it's still possible to
  read something from \code{std::cin}
\end{frame}

\begin{frame}[fragile]{\code{double}}

  Type representing a floating-point number

  \begin{itemize}
  \item<2-> Set of values: subset of $\mathbb{R}$
  \item<3-> Operations: addition, subtraction, multiplication, division, comparisons, \ldots
  \item<4-> Representation: \href{https://en.wikipedia.org/wiki/IEEE_754}{IEEE 754}
  \item<5-> 64 bits, smallest values $\approx\pm10^{-308}$, largest values $\approx\pm10^{308}$
  \item<6-> Precision is about 16 decimal digits
  \item<6-> Literals in the form \opt{\textit{sign}} \textit{significand} \opt{\textit{exponent}}
    \begin{itemize}
    \item \code{42.0 1. -1.5 12.34e3 -.34E-3 -1234e-2}
    \item \code{\ddd{}e\textit{n}}/\code{\ddd{}E\textit{n}} means $\times 10^{n}$
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{\code{float}}

  Type representing a floating-point number

  \begin{itemize}
  \item<2-> Set of values: subset of $\mathbb{R}$
  \item<3-> Operations: addition, subtraction, multiplication, division, comparisons, \ldots
  \item<4-> Representation: \href{https://en.wikipedia.org/wiki/IEEE_754}{IEEE 754}
  \item<5-> 32 bits, smallest values $\approx\pm10^{-38}$, largest values $\approx\pm10^{38}$
  \item<6-> Precision is about 7 decimal digits
  \item<6-> Literals in the form \opt{\textit{sign}} \textit{significand} \opt{\textit{exponent}} \code{F}
    \begin{itemize}
    \item \code{42.0f 1.F -1.5f 12.34e3F -.34E-3f -1234e-2F}
    \item Same as double but with an \code{f} or \code{F} suffix
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Handle floating-point numbers with care}

  \begin{itemize}
  \item<1-> Floating-point numbers are \textbf{not} real numbers
    \begin{itemize}
    \item Finite representation $\implies$ there is a previous and a next
    \end{itemize}
  \item<2-> When managing floating-point numbers one should take into account
    rounding errors and inexact representations
    \begin{codeblock}<3->{
float x = 1\textquotesingle000\textquotesingle000\textquotesingle000;
\uncover<4->{std::cout << std::setprecision(10)
  << x - 32 << \upquote{ } << x << \upquote{ } << x + 32}\uncover<5->{ // 1000000000 1000000000 1000000000}
\uncover<6->{  << x + 32 - x << \upquote{ } << x - x + 32;}\uncover<7->{    // 0 32}}\end{codeblock}
  \item<8-> Floating-point math in general is not associative
  \item<9-> When comparing floating-point numbers avoid the use of equality
  \item<10-> See \href{https://cr.yp.to/2005-590/goldberg.pdf}{What Every
      Computer Scientist Should Know About Floating Point Arithmetic}
 \end{itemize}

\end{frame}

\begin{frame}[fragile]{Standard mathematical functions}

  The \href{https://en.cppreference.com/w/cpp/header/cmath}{\code{cmath}} header
  includes many ready-to-use mathematical functions
  \begin{itemize}
  \item Exponential
  \item Power
  \item Trigonometric
  \item Interpolation
  \item Hyperbolic
  \item Floating-point manipulation, classification and comparison
  \item \ldots
  \end{itemize}

  \begin{codeblock}<2->{
#include <cmath>
\ddd
double x = \ddd;
std::sqrt(x);
std::pow(x, .5);
std::sin(x);
std::log(x);
std::abs(x);}\end{codeblock}
\end{frame}

\begin{frame}[fragile]{Type conversions}

    \begin{itemize}
    \item A value of type \code{T1} may be converted \textbf{implicitly} to a
      value of type \code{T2} in order to match the expected type in a certain
      situation
      \begin{codeblock}<2->{
1 + 2.3}\end{codeblock}
      \begin{itemize}[<3->]
      \item between numbers and bool
      \item between signed and unsigned numbers
      \item between numbers of different size
      \item between integral and floating-point numbers
      \item \ldots
      \end{itemize}

    \item<4-> Conversions sometimes are surprising
    \item<5-> Conversions can be explicit using \code{static_cast}
      \begin{codeblock}<.->{
1 + static_cast<int>(2.3)}\end{codeblock}
    \item<6-> Mechanims exist to define implicit and explicit conversions
      involving user-defined types

    \end{itemize}

\end{frame}

\begin{frame}[fragile]{\code{const}-safety}

  \begin{itemize}
  \item Data qualified as \code{const} is logically immutable
  \item Data that is meant to be immutable should be \code{const}
  \end{itemize}

  \begin{codeblock}<2->{
int \alert{const} x = 1\textquotesingle000\textquotesingle000\textquotesingle000; // or const int
\uncover<3->{std::cout << x + 32;    // ok, read-only}
\uncover<4->{x += 32;                // error, trying to modify}
\uncover<5->{int const y;            // error, not initialized and not modifiable later}
}\end{codeblock}

\begin{codeblock}<6->{
std::string \alert{const} message = "Hello";
\uncover<7->{std::cout << message + " Francesco";      // ok, read-only}
\uncover<8->{message += " Francesco";                  // error, trying to modify}
\uncover<9->{std::string const empty_message;          // ok! empty string}}\end{codeblock}

  \begin{itemize}[<10->]
  \item Primitive types (e.g. \code{int}) and user-defined types such as
    \code{std::string}) behave differently with respect to \textit{default
      initialization}, i.e. without an explicit initial value
    \begin{itemize}
    \item User-defined types can define what default initialization means
    \item For \code{std::string} it means ``empty string''
    \item More later
    \end{itemize}
  \end{itemize}

\end{frame}

\begin{frame}{Functions}

  \begin{itemize}[<+->]
  \item A function abstracts away a piece of code that performs a well-defined
    task behind a well-defined interface
  \item A function associates a block of statements with
    \begin{itemize}
    \item a name
    \item a list of zero or more parameters
    \end{itemize}
  \item A function may return a result
  \end{itemize}

  \begin{itemize}[<+->]
  \item Let's consider the code that computes the integer square root
    \begin{itemize}
    \item Let's give it a name $\rightarrow$ \code{isqrt}
    \item We pass \code{isqrt} a number $\rightarrow$ the list of parameters has
      only one item of type \code{int}
    \item \code{isqrt} computes a value that we want back $\rightarrow$ the
      function returns a value of type \code{int}
    \end{itemize}
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{The \code{isqrt} function}

  \begin{columns}[T]
    \begin{column}{.5\textwidth}
      \begin{codeblock}
#include <iostream>

int main()
\{
  int n;
  std::cin >{}> n;
  int i = 1;
  while (i * i < n) \{
    ++i;
  \}
  if (i * i > n) \{
    --i;
  \}
  std::cout << i << \bslashn;
\}\end{codeblock}

      \vskip .5cm

      \uncover<2>{Names on the two sides of the call are independent}
    \end{column}

    \begin{column}{.5\textwidth}
      \begin{codeblock}
#include <iostream>

int isqrt(int \alert<2>{n})  \only<1>{// \alert{function definition}}
\{
  int i = 1;
  while (i * i < n) \{
    ++i;
  \}
  if (i * i > n) \{
    --i;
  \}
  return \alert<2>{i};      \only<1>{// \alert{return statement}}
\}

int main()
\{
  int \alt<1>{n}{\alert<2>{num}};
  std::cin >{}> \alt<1>{n}{\alert<2>{num}};
  int \alt<1>{i}{\alert<2>{result}} = isqrt(\alt<1>{n}{\alert<2>{num}});  \only<1>{// \alert{function call}}
  std::cout <{}< \alt<1>{i}{\alert<2>{result}} <{}< \bslashn;
\}\end{codeblock}
    \end{column}

  \end{columns}

\end{frame}

\begin{frame}{Functions \insertcontinuationtext}

  \begin{itemize}
  \item<1-> A function needs to be declared/defined before its use

    \textit{return-type} \textit{function-name} \code{(} \textit{parameter-list} \code{);}

    \textit{return-type} \textit{function-name} \code{(} \textit{parameter-list} \code{) \{ \ddd \}}

    \visible<2->{

      \code{int isqrt(int);}

      \code{int count_words(std::string s) \{ \ddd \}}

      \code{double pow(double base, double exponent);}

      \code{void print(std::string);}

      \code{int generate_random_number();}
    }

  \item<3-> Each parameter in the parameter list is of the form

    \textit{type \opt{name}}

    \textit{type} is mandatory, \textit{name} is optional

  \item<4-> Parameters are separated by commas

  \item<5-> The parameter list can be empty, i.e. \code{()}

  \item<6-> The \code{return} statement returns the result (and the control) to
    the calling function

  \item<7-> If the function returns nothing, the return type is \code{void}
  \end{itemize}

\end{frame}

\begin{frame}{Functions \insertcontinuationtext}

  \begin{itemize}

  \item<1-> A function has only one entry point, but it may have multiple exit
    points, i.e. there can be multiple \code{return} statements

    \begin{itemize}
    \item For a function returning a non-\code{void} type

      \code{return} \textit{expression}\code{;}

      The result of \textit{expression} must be convertible to the return type

    \item For a function returning \code{void}

      \code{return;}

      In this case the \code{return} is optional (at the end of the function)

    \end{itemize}

  \end{itemize}
\end{frame}

\begin{frame}{Functions \insertcontinuationtext}

  \begin{itemize}
  \item<1-> Calling/invoking a function is a type of expression of the form $F(E_1,
    E_2, \ldots, E_N)$
    \begin{itemize}
    \item $F$ is an expression that identifies a function, typically its name
    \item Each $E_i$ is an expression, whose value is used to initialize the
      corresponding parameter (i.e. in the same position) in the function
      declaration
    \end{itemize}

    \visible<2->{
      \code{int s = isqrt(24);}

      \code{std::cout << count_words("Hello, " + name);}

      \code{print(std::to_string(pow(isqrt(24), 2)));}
    }

  \item<3-> A function can call other functions
  \item<4-> A function should not be too long; if it is, try to break it into
    multiple parts, each implemented as a function
  \item<5-> A function can call itself, directly or indirectly
    \begin{itemize}
    \item This is called \textit{recursion}
    \item Often an elegant alternative to a loop
    \item Not easy to master, don't abuse
    \end{itemize}
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{The \code{main} function}
  \begin{itemize}
  \item The \code{main} (special) function is the entry point of a program
  \item It can have two forms
    \begin{itemize}
    \item \code{int main() \{\ddd\}}
    \item \ldots (see later)
    \end{itemize}
  \item If there is no \code{return} statement, an implicit \code{return 0;} is assumed
    \begin{itemize}
    \item $0$ means success, different from $0$ means failure
    \item Or use \code{EXIT_SUCCESS} and \code{EXIT_FAILURE} from \code{<cstdlib>}
    \item The exit value is available to the shell via the \code{\$?} variable
    \end{itemize}
  \end{itemize}

  \begin{codeblock}<2->{
#include <cstdlib>

int main()
\{
  int n;
  std::cin >{}> n;
  if (std::cin.fail() || n < 0) \{
    std::cerr << "Invalid number\bslash{}n";
    return EXIT_FAILURE;
  \}
  \ddd
\}}\end{codeblock}

\end{frame}

\begin{frame}{Exercises}
  \begin{itemize}
  \item Write a function \code{pow} that takes two \code{int}s and computes and
    returns the value of the first (the base) raised to the power of the second
    (the exponent)
  \item Write a function \code{gcd} that takes two \code{int}s and computes the
    Gratest Common Denominator using the
    \href{https://en.wikipedia.org/wiki/Euclidean_algorithm}{Euclid's algorithm}
  \item Write a function \code{lcm} that takes two \code{int}s and computes the
    Least Common Multiple
  \item Write a function \code{is\_prime} that takes an \code{int} and tells if
    it's a prime number
  \item More on \href{https://edabit.com/}{edabit}, \href{https://leetcode.com/}{leetcode}, \ldots
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{How do we know the code we write is correct?}

  \begin{itemize}[<+->]
  \item Correctness is the result of the application of multiple good practices
    to the software developmente process
  \item One of the most effective techniques is \textbf{testing}
    \begin{itemize}
    \item Execute the code with reasonable and unreasonable input and see if it
      behaves according to the expectations
    \item The purpose of testing is to (try to) \alert{break} the code
    \end{itemize}
  \item Here we focus on a form of testing called \textit{unit testing}, where
    the units (of code) under test are, for example, functions
  \item There are many tools/frameworks to do unit testing (Google Test, Catch,
    Doctest, Boost.Test, \ldots)
  \item Let's use \href{https://github.com/onqtam/doctest}{Doctest}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{How to use Doctest}

  \begin{itemize}
  \item On \href{https://godbolt.org/}{godbolt} it's available selecting it
    under ``Libraries''
  \item Otherwise download locally a single
    \href{https://raw.githubusercontent.com/onqtam/doctest/master/doctest/doctest.h}{\textit{header
        file}} into the directory containing your code, e.g. using \code{wget}
    or \code{curl}
  \item At the top of your \Cpp{} file add the lines
    \begin{codeblock}
#define DOCTEST\_CONFIG\_IMPLEMENT\_WITH\_MAIN
#include "doctest.h"\end{codeblock}
  \item Don't add \code{main} into your file
  \item After the code of the function(s) you have written, add lines like the
    following:
    \begin{codeblock}
TEST_CASE("Testing isqrt") \{
  CHECK(isqrt(0) == 0);
  CHECK(isqrt(9) == 3);
  CHECK(isqrt(10) == 3);
  CHECK(isqrt(-1) == 0);
  \ddd
\}\end{codeblock}

  \end{itemize}

\end{frame}

\begin{frame}{Memory layout of a process}

  \begin{itemize}
  \item A process is a running program
  \item When a program is started the operating system brings the contents of
    the corresponding file into memory according to well-defined conventions
  \end{itemize}

  \begin{columns}
    \begin{column}{.7\textwidth}
      \begin{itemize}
        \item[]
      \begin{itemize}
      \item Stack
        \begin{itemize}
        \item function local variables
        \item function call bookkeeping
        \end{itemize}
      \item Heap
        \begin{itemize}
        \item dynamic allocation
        \end{itemize}
      \item Global data
        \begin{itemize}
        \item literals and variables
        \item initialized and uninitialized (set to 0)
        \end{itemize}
      \item Program instructions
      \end{itemize}
    \end{itemize}
  \end{column}

    \begin{column}{.3\textwidth}
      \centering\includegraphics[height=.5\textheight]{images/process-memory-layout}
    \end{column}
  \end{columns}

\end{frame}

\begin{frame}[fragile]{Functions and the stack}

  \begin{columns}
    \begin{column}{.5\textwidth}
      \begin{codeblock}
\alert<4>{int isqrt(int n)
\{
  int i} \alert<6>{= 1};
  \alert<7>{while (i * i < n) \{
    ++i;
  \}
  if (i * i > n) \{
    --i;
  \}}
  \alert<8>{return i;}
\alert<4>{\}}

\alert<2>{int main()
\{
  int num};
  \alert<3>{std::cin >{}> num;}
  \alert<2>{int result} \alert<8>{=} \alert<4>{isqrt(}\alert<5>{num}\alert<4>{)};
  std::cout <{}< result <{}< \bslashn;
\alert<2>{\}}\end{codeblock}

    \end{column}

    \begin{column}{.4\textwidth}
      \begin{tikzpicture}[
        mem/.style={
          minimum width=2cm,
          inner sep=0pt,
          outer sep=0pt,
          draw=black
        },
        frame/.style={
          minimum width=2cm,
          inner sep=0pt,
          outer sep=0pt,
          draw=black,
          thick,
          fill=green!50!white
        },
        var/.style={
          node font=\ttfamily\scriptsize,
          minimum height=.5cm,
          minimum width=2cm,
          draw=black,
          fill=green!30!white,
          inner sep=0pt,
          outer sep=0pt
        },
        anchor=south west]
        \visible<1->{
          \node at (0,0) [
          mem,
          minimum height=7cm,
          label={90:Stack}] {};
        }
        \visible<2-9>{
          \node (main) at (0,4) [
            frame,
            minimum height=2cm,
            label={[yshift=.9cm]0:\scriptsize\tt main}
          ] {};
          \node (result) [
            var,
            above=3ex of main.south,
            label={180:\scriptsize\tt result}
          ] {\only<8->{2}};
          \node (num) [
            var,
            above=0pt of result,
            label={180:\scriptsize\tt num}
          ] {\only<3->{5}};
        }
        \visible<4-8>{
          \node (isqrt) [
            frame,
            below=0pt of main,
            minimum height=2cm,
            label={[yshift=.9cm]0:\scriptsize\tt isqrt}
          ] {};
          \node (i) [
            var,
            above=3ex of isqrt.south,
            label={180:\scriptsize\tt i}
          ] {\only<6>{1}\only<7->{2}};
          \node (n) [
            var,
            above=0pt of i,
            label={180:\scriptsize\tt n}
          ] {\only<5->{5}};
        }
        \visible<2-3,9>{
          \node (main rsp) at ([xshift=-2cm]main.south west) {\scriptsize\tt \%rsp};
          \draw[->] (main rsp) -- +(1.5cm,0);
        }
        \visible<4-8>{
          \node (isqrt rsp) at ([xshift=-2cm]isqrt.south west) {\scriptsize\tt \%rsp};
          \draw[->] (isqrt rsp) -- +(1.5cm,0);
        }
      \end{tikzpicture}
    \end{column}

  \end{columns}

  \uncover<10>{}

\end{frame}

\begin{frame}{Pass by-value, return by-value}

  Given a function

  % \tikzref doesn't work inside \code nor inside \texttt; to be investigated

  \begin{equation*}
    \code{R F(T$_1$ p}\tikzref{p1}\code{$_1$, \ddd, T$_n$ p}\tikzref{pn}\code{$_n$) \{ \ddd{} return E}\tikzref{er}\code{$_R$; \} }
  \end{equation*}

  and a function call

  \begin{equation*}
    \code{R r}\tikzref{r}\code{ = F(E}\tikzref{e1}\code{$_1$, \ddd, E}\tikzref{en}\code{$_n$);}
  \end{equation*}

  \begin{itemize}
  \item<2-> Each \code{p$_i$} is initialized as a \alert{copy} of the value of
    expression \code{E$_i$}
    \begin{itemize}
    \item If \code{E$_i$} is just a variable, changing \code{p$_i$} inside the
      function doesn't change the variable
    \end{itemize}
  \item<3-> \code{r} is initialized as a \alert{copy} of the value of expression
    \code{E$_R$}
  \end{itemize}

  \visible<2->{
    \tikz[remember picture, overlay] \draw[-Stealth,blue,line width=1pt] ([yshift=1ex] e1) -- ([yshift=-1ex]p1);
    \tikz[remember picture, overlay] \draw[-Stealth,blue,line width=1pt] ([yshift=1ex] en) -- ([yshift=-1ex]pn);
  }
  \visible<3->{
    \tikz[remember picture, overlay] \draw[-Stealth,brown,line width=1pt] ([yshift=-1ex] er) -- ([yshift=1ex]r);
  }

\end{frame}

\begin{frame}{Stack frame}

  \begin{itemize}[<+->]
  \item A piece of memory allocated and dedicated to the execution of a function
  \item It contains local variables (including function parameters), return
    address, saved registers, \ldots
  \item Managed in a Last-In, First-Out (LIFO) way
  \item The size of the stack frame is computed by the compiler
  \item There is a special register (the stack pointer register, \code{\%rsp})
    that indicates the frame of the currently running function
  \item At runtime the allocation/deallocation of a frame consists simply in
    subtracting/adding that frame size to the stack pointer register
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Passing by value may be expensive}

  Let's consider a function that counts the number of words in a string

  \begin{columns}
    \begin{column}{.5\textwidth}

      \begin{codeblock}
int count_words(std::string \alert<5>{s})
\{
  int count = 0;
  \ddd
  return count;
\}

\alert<2>{int main()
\{
  std::string text} \alert<3>{= \ddd};
  \alert<2>{int const res} = \alert<4>{count_words(}\alert<5>{text}\alert<4>{)};
  std::cout <{}< res <{}< \bslashn;
\alert<2>{\}}\end{codeblock}

      \begin{itemize}
      \item<5-> \code{s} is a \textbf{copy} of \code{text}
      \item<6-> I'm slightly cheating: not all string memory goes on the stack
      \end{itemize}

    \end{column}

    \begin{column}{.4\textwidth}

      \begin{tikzpicture}[
        mem/.style={
          minimum width=2cm,
          inner sep=0pt,
          outer sep=0pt,
          draw=black
        },
        frame/.style={
          minimum width=2cm,
          inner sep=0pt,
          outer sep=0pt,
          draw=black,
          thick,
          fill=green!50!white
        },
        var/.style={
          node font=\ttfamily\scriptsize,
          minimum height=.5cm,
          minimum width=2cm,
          draw=black,
          fill=green!30!white,
          inner sep=0pt,
          outer sep=0pt
        },
        anchor=south west
        ]
        \node at (0,0) [
          mem,
          minimum height=6cm
        ] {};
        \visible<2->{
          \node (main) at (0,3) [
            frame,
            minimum height=2.5cm,
            label={[yshift=1.1cm]0:\scriptsize\tt main}
          ] {};
          \node (result) [
            var,
            above=3ex of main.south,
            label={180:\scriptsize\tt res}
          ] {};
          \node (text) [
            var,
            minimum height=1cm,
            text width=2cm,
            align=center,
            above=0pt of result,
            label={180:\scriptsize\tt text}
          ] {\only<3->{\tiny\textit{Nel mezzo del cammin di nostra vita\ldots}}};
        }
        \visible<4->{
          \node (countwords) [
            frame,
            below=0pt of main,
            minimum height=2.5cm,
            label={[yshift=1.1cm]0:\scriptsize\tt count_words}
          ] {};
          \node (count) [
            var,
            above=3ex of countwords.south,
            label={180:\scriptsize\tt count}
          ] {};
          \node (s) [
            var,
            minimum height=1cm,
            text width=2cm,
            align=center,
            above=0pt of count,
            label={180:\scriptsize\tt s}
          ] {\only<5->{\tiny\textit{Nel mezzo del cammin di nostra vita\ldots}}};
        }
      \end{tikzpicture}
    \end{column}

  \end{columns}
\end{frame}

\begin{frame}[fragile]{References}

  \begin{itemize}
  \item A variable declared as a \alert{reference} of a type \code{T} is another
    name (an \textit{alias}) for an existing object of type \code{T}
  \end{itemize}

  \begin{tikzpicture}[
      mem/.style={
        node font=\ttfamily\scriptsize,
        minimum height=.5cm,
      },
      location/.style={
        mem,
        draw=black!50,
        minimum width=2cm,
        fill=green!20!white,
      },
      every node/.style={
        mem,
      },
      anchor=south west,
      node distance=0,
    ]

    \visible<2->{
      \node (memory) at (0,0) [mem, draw=black!50, minimum width=\textwidth] {};

      \node (i) at (2,0) [
        location,
        "i" below,
        "\alert<3>{ri}" {visible on=<3->,yshift=-0.3cm,below}
      ] {\only<-4>{12}\only<5-6>{34}\only<7->{56}};

      \node (j) at (7,0) [
        location,
        "j" below
      ] {56};
    }

  \end{tikzpicture}

  \begin{codeblock}<2->{
int i = 12;
int j = 56;
\uncover<3->{int\alert<3>{\&} ri = i;         // reference declarator}
\uncover<4->{ri == 12;            // true}
\uncover<5->{ri = 34;}
\uncover<6->{ri == 34 \&\& i == 34; // true}
\uncover<7->{ri = j;}
\uncover<8->{ri == 56 \&\& i == 56; // true}
\uncover<9->{int\& r;              // error}}\end{codeblock}

  \begin{itemize}
  \item<10-> A reference must be initialized to refer to a valid object
  \item<10-> A reference cannot \textit{rebind} (be re-associated) to another
    object
  \item<11-> For a given type \code{T}, \code{T\&} is a \textit{compound} type,
    distinct from \code{T}
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Passing by reference}

  \begin{columns}
    \begin{column}{.5\textwidth}

      \begin{codeblock}
int count_words(std::string\alert<1->{\&} s)
\{
  \alert<5>{int count = 0;}
  \alert<6>{\ddd}
  \alert<7>{return count;}
\}

\alert<2>{int main()
\{
  std::string text} \alert<3>{= \ddd};
  \alert<2>{int const res} \alert<7>{=} \alert<4>{count_words(text)};
  std::cout <{}< res <{}< \bslashn;
\alert<2>{\}}\end{codeblock}

      \uncover<8>{}
      \uncover<9>{}

      \vskip .5 cm

      \visible<4->{\scriptsize (*) In general it's unspecified if a reference
        occupies storage. Here probably it does (called s$'$)}

    \end{column}

    \begin{column}{.4\textwidth}

      \begin{tikzpicture}[
        mem/.style={
          minimum width=2cm,
          inner sep=0pt,
          outer sep=0pt,
          draw=black
        },
        frame/.style={
          minimum width=2cm,
          inner sep=0pt,
          outer sep=0pt,
          draw=black,
          thick,
          fill=green!50!white
        },
        var/.style={
          node font=\ttfamily\scriptsize,
          minimum height=.5cm,
          minimum width=2cm,
          draw=black,
          fill=green!30!white,
          inner sep=0pt,
          outer sep=0pt
        },
        anchor=south west
        ]
        \node at (0,0) [
          mem,
          minimum height=6cm
        ] {};
        \visible<2-8>{
          \node (main) at (0,3) [
            frame,
            minimum height=2.5cm,
            label={[yshift=1.1cm]0:\scriptsize\tt main}
          ] {};
          \node (result) [
            var,
            above=3ex of main.south,
            label={180:\scriptsize\tt res}
          ] {\only<7-8>{12345}};
          \node (text) [
            var,
            minimum height=1cm,
            text width=2cm,
            align=center,
            above=0pt of result,
            "\scriptsize\tt text" left,
            "\scriptsize\tt\alert<4-7>{s}" {visible on=<4-7>,xshift=-.8cm,left}
          ] {\only<3->{\tiny\textit{Nel mezzo del cammin di nostra vita\ldots}}};
        }
        \visible<4-7>{
          \node (countwords) [
            frame,
            below=0pt of main,
            minimum height=1.7cm,
            label={[yshift=.5cm]0:\scriptsize\tt count_words}
          ] {};
          \node (count) [
            var,
            above=3ex of countwords.south,
            label={180:\scriptsize\tt count}
          ] {\only<5>{0}\only<6-7>{12345}};
          \node (sref) [
            var,
            above=0pt of count,
            label={180:\scriptsize\tt s$'$}
          ] {(*)};
        }
      \end{tikzpicture}
    \end{column}

  \end{columns}
\end{frame}

\begin{frame}[fragile]{\code{const} and references}

  \begin{codeblock}
std::string name = "Francesco";
\uncover<2->{std::string\alert{\&} rname = name;        // ok, can read/modify name via rname}
\uncover<3->{std::string \alert{const\&} crname = name; // ok, crname is a read-only view of name}\end{codeblock}

  \begin{codeblock}<4->{
std::string \alert{const} name = "Francesco";
\uncover<5->{std::string\alert{\&} rname = name;        // error, could modify name via rname}
\uncover<6->{std::string \alert{const\&} crname = name; // ok, can only read name via rcname}}\end{codeblock}

  \begin{codeblock}<7->{
int count\_words(std::string \alert{const\&} s)
\{
   \ddd
\}}\end{codeblock}
\end{frame}

\begin{frame}[fragile]{How to pass arguments to functions}
  \begin{itemize}
  \item For input parameters
    \begin{itemize}
    \item If the type is primitive, pass by value
      \begin{codeblock}
int isqrt(int n);        // good
int isqrt(int const& n); // bad!\end{codeblock}
    \item Otherwise pass by const reference
      \begin{codeblock}
int count\_words(std::string const\&);\end{codeblock}
    \end{itemize}
  \item For input-output or output parameters, pass by non-const reference
    \begin{codeblock}
void to_lowercase(std::string\& s);
void read_from_cin(int& n);\end{codeblock}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Function overloading}

  \begin{itemize}
  \item Multiple functions can have the same name
  \item But different lists of parameters (number and/or types)
  \item The compiler chooses the function that best matches the arguments in
    the call
    \begin{itemize}
    \item It usually does what is expected, possibly applying appropriate
      implicit conversions, but not always
    \item Compilation error if there is no match or no unique best match
    \end{itemize}
  \item The return type doesn't matter
  \end{itemize}

  \begin{codeblock}
void foo(int);
int  foo(int, char);
bool foo(double);
int  foo(std::string s);

foo(0);             // call foo(int)
foo(0, \upquote{0});        // call foo(int, char);
foo(0.);            // call foo(double)
foo(std::string\{\}); // call foo(std::string)
foo(0L);            // long int, ambiguous, error
foo(\upquote{a});           // call foo(int)
foo("a");           // call foo(std::string)\end{codeblock}

\end{frame}

\begin{frame}[fragile]{Conditional/ternary operator expression}

  \begin{center}
    \textit{expression}$_{condition}$ \code{?} \textit{expression}$_{true}$ \code{:} \textit{expression}$_{false}$
  \end{center}

  \begin{codeblock}
int gcd(int a, int b)
\{
  return (b == 0) \alert{?} a \alert{:} gcd(b, a \% b);
\}\end{codeblock}

  \begin{itemize}
  \item Evaluate \textit{expression}$_{condition}$, whose value is of type
    (convertible to) \code{bool}
  \item If \code{true}, \textit{expression}$_{true}$ is evaluated and the
    resulting value is the value of the whole expression
  \item If \code{false}, \textit{expression}$_{false}$ is evaluated and the
    resulting value is the value of the whole expression
  \end{itemize}

  \begin{itemize}
  \item Similar to an \code{if} statement, but usable (and useful) where only an
    expression is allowed
  \item The types of \textit{expression}$_{true}$ and
    \textit{expression}$_{false}$ are subject to some constraints, but let's
    assume that they have to be the same
  \end{itemize}

\end{frame}

\begin{frame}{\code{break} and \code{continue} for loops}

  \begin{itemize}
  \item<1-> Within a loop block, the \code{break} statement allows to terminate
    the loop
  \item<2-> Within a loop block, the \code{continue} statement allows to jump to
    the end of the current iteration of the loop
  \item<3> The same effect can be obtained with appropriate use of conditionals,
    but the resulting code may be more complicated
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Object initialization with braces}

  \begin{itemize}
  \item An object can be initialized specifying its value between \code{\{\}}

    \begin{codeblock}
int i\{123\};
float f\{123.F\};
std::string s\{"hello"\};\end{codeblock}

  \item Introduced as a \textit{universal} form of initialization that could
    replace all others, but there are situations where it's not usable

  \item Protects against \textit{narrowing}, i.e. loss of information caused by
    implicit conversions

    \begin{codeblock}
double d\{1.\};         // ok, no conversion
float f1\{1.\};         // ok, no information loss
float f2\{d\};          // error
float f3\{9\textquotesingle{}999\textquotesingle{}999\};  // ok, no information loss
float f3\{99\textquotesingle{}999\textquotesingle{}999\}; // error
int i\{1.\};            // error
int g\{d\};             // error\end{codeblock}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{\code{char}}

  Type representing a character

  \begin{itemize}[<+->]
  \item Set of values: letters in the alphabet (lower- and upper-case), digits,
    punctuation marks, some special characters, \ldots
  \item Size: typically 1 byte, but not necessarily
  \item Representation: let's assume the
    \href{https://en.wikipedia.org/wiki/ASCII}{ASCII} encoding
  \item Literals: characters between single quotes
    \begin{itemize}[<.->]
    \item \code{\upquote{a} \upquote{B} \upquote{7} \upquote{,} \upquote{?} \upquote{\#} \upquote{/}}
    \end{itemize}
  \item Some character literals need to be expressed as \code{\bslash}-escaped
    sequences
    \begin{itemize}[<.->]
    \item \code{\upquote{\bslash\textquotesingle} \upquote{\bslash\bslash} \upquote{\bslash{n}} \upquote{\bslash{t}} \upquote{\bslash{0}}}
    \end{itemize}
  \item A \code{char} is an integral type so it supports integral operations
    \begin{itemize}
    \item \code{std::cout <{}< \upquote{9} - \upquote{0}; // 9}
    \item \code{c < \upquote{z};}
    \end{itemize}
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{\textit{range-for} loop}

    \code{for (} \textit{range-declaration} \code{:} \textit{range-expression} \code{)} \textit{statement}

  \begin{itemize}
  \item Simplified form of a \code{for} loop, to iterate on all the elements of
    a \textit{range} (sequence), such as a string of characters
  \item<2-> Execute repeatedly \textit{statement} for all the elements of the range
  \item<3-> \textit{range-declaration} declares a variable of the same type of
    an element of the range
    \begin{itemize}
    \item Can (and should) be a (const) reference
    \end{itemize}
  \item<4-> \textit{range-expression} represents the range to iterate over
  \item<5-> More on ranges later
  \end{itemize}

  \begin{codeblock}
std::string s\{"Hello!"\};
for (char& c : s) \{
  c = std::toupper(c); 
\}

for (int i : \{1, 2, 3, 4, 5\}) \{
  std::cout << i << \upquote{ };
\}\end{codeblock}

\end{frame}

\begin{frame}{Exercises}

  \begin{itemize}
  \item Write a function that takes a \code{char} and returns the corresponding
    lowercase character if it is a letter; the same char otherwise
    \begin{itemize}
    \item e.g. \upquote{A} $\rightarrow$ \upquote{a}, \upquote{a} $\rightarrow$
      \upquote{a}, \upquote{;} $\rightarrow$ \upquote{;}
    \end{itemize}
  \item Write a function that takes two numeric operands of type \code{double}
    and one operator of type \code{char} and returns the result of applying that
    operator to the two operands. For example if the two operands have values
    $2.0$ and $3.0$ respectively and the operator has value \code{\upquote{+}},
    then the function returns a result with value $5.0$. If the operator is
    invalid, the function returns $0$.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Returning a reference}

  \begin{itemize}
  \item A function can return a reference only if the referenced object survives
    the end of the function
    \begin{itemize}
    \item In the caller, the reference would refer to an object that doesn't
      exist anymore
    \end{itemize}
  \item In particular do not return a reference to a function local variable

    \begin{columns}
      \begin{column}{.5\textwidth}
        \begin{codeblock}
// bad
int& add(int a, int b)
\{
  int result = a + b;
  return result;
\}\end{codeblock}
      \end{column}
      \begin{column}{.5\textwidth}
        \begin{codeblock}
int& increment(int& a) // ok
\{
  ++a;
  return a;
\}\end{codeblock}
      \end{column}
    \end{columns}

  \item Useful to compose multiple function calls on the same object
    \begin{codeblock}
std::string s\{\ddd\};
trim_left(trim_right(tolower(s)));\end{codeblock}

  \end{itemize}
  
\end{frame}

\begin{frame}{Data abstraction}
  \begin{itemize}[<+->]
  \item The \Cpp{} language has a strong focus on building lightweight data
    abstractions
    \begin{itemize}
    \item The source code can use terminology and notation close to the problem
      domain, making it more expressive
    \item There is little (if any) overhead in terms of space or time during
      execution
    \end{itemize}
  \item \code{class} and \code{struct} are the primary mechanism to define new
    compound types on top of fundamental types
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Data structure}

  Let's introduce a type to represent complex numbers

  \begin{columns}[t]

    \begin{column}{.5\textwidth}

  \begin{codeblock}<2->{
struct Complex \{
  \alt<-5>{\ddd
  }{double r; // data member
  double i;}
\};

\uncover<3->{double norm2(Complex c);
Complex sqrt(Complex c);

Complex c\{\alt<-5>{\ddd}{1., 2.}\};
double n = norm2(c);
Complex c2 = sqrt(c);}

\uncover<4->{Complex& cr = c;  // reference}}\end{codeblock}

    \end{column}

    \begin{column}{.5\textwidth}
      \begin{codeblock}<5->{
double norm2(Complex c) \{
  return \uncover<7->{c\alert<7>{.}r * c\alert<7>{.}r + c\alert<7>{.}i * c\alert<7>{.}i};
\}

\uncover<8->{double norm2(Complex\alert<8>{ const\&} c) \{
  return \uncover<9->{c.r * c.r + c.i * c.i};
\}}}\end{codeblock}

      \begin{itemize}
      \item<6-> A \code{Complex} is composed of two \code{double}s
      \item<7-> The \code{.} (dot) operator allows to access a member of an
        object of class type (such as a \code{struct})
      \end{itemize}
    \end{column}

  \end{columns}

  \begin{tikzpicture}[
      anchor=south west,
      node distance=0,
    ]
    
    \visible<3->{
      \node at (0,0) [memory] {};

      \node at (2.9,-0.1) [
        rectangle,
        "\code{c}" below,   
        fill=green!10!white,
        draw=black!40,
        minimum width=2.2cm,
        minimum height=0.7cm,
      ] {};
    }
    \visible<6->{
      \node (r) at (3,0) [word, "\code{r}" above] {\only<6->{1.}};
      \node (i) [word, right=of r, "\code{i}" above] {\only<6->{2.}};
    }
    
  \end{tikzpicture}

\end{frame}

\begin{frame}[fragile]{Operations}

  It's possible to define operations on user-defined types

  \begin{codeblock}
struct Complex \{
  double r;
  double i;
\};

\uncover<3->{bool \uncover<4->{\alert<4>{operator==}}(Complex const& a, Complex const& b) \{
  return a.r == b.r && a.i == b.i;
\}}

\uncover<5->{Complex \uncover<6->{\alert<6>{operator+}}(Complex const& a, Complex const& b) \{
  return Complex\{a.r + b.r, a.i + b.i\};
\}}

c2 \alert<2>{=} c1\uncover<2->{       // \alert<2>{generated by the compiler, if used}}
c1 \alert<3-4>{==} c2
c1 \alert<5-6>{+} c2
z = z * z + c
2. * c1
\ddd\end{codeblock}

\uncover<7>{}

\end{frame}

\begin{frame}[fragile]{Operator overloading}


  \begin{itemize}[<+->]
  \item \Cpp{} offers the possibility to define the meaning of most of the
    operators available for fundamental types when applied to user-defined types
  \item Syntactically this is done via the definition of appropriate functions
  \item Given an operator \textit{@}, the function name is called
    \code{operator\textit{@}}
  \item Although there are some constraints on the number and types of the
    parameters and on the type of the return value, the overloaded operators
    are just functions
  \item The behaviour of the overloaded operator should reproduce the behaviour
    of the original one
  \item Some behaviours cannot be changed, e.g. associativity
  \end{itemize}

\end{frame}

\begin{frame}{Exercises}
  \begin{itemize}
  \item Define some other operators and functions for Complex
  \item Write a function to compute the solutions of an equation of the form
    $ax^2 + bx + c = 0$, given the three coefficients
  \end{itemize}
\end{frame}

\begin{frame}{\Cpp{} standard evolution}

  \begin{itemize}
  \item Working drafts, almost the same as the final published document
    \begin{description}
    \item [\Cpp{}03] \url{https://wg21.link/n1905}
    \item [\Cpp{}11] \url{https://wg21.link/std11}
    \item [\Cpp{}14] \url{https://wg21.link/std14}
    \item [\Cpp{}17] \url{https://wg21.link/std17}
    \item [\Cpp{}20] \url{https://wg21.link/std20}
    \item [\Cpp{}2b] \url{https://wg21.link/std} (current draft, will become
      \Cpp{}23)

      Available also at \url{https://eel.is/c++draft} in HTML format
    \end{description}

    \LaTeX sources at \url{https://github.com/cplusplus/draft}

  \item The default mode for \code{g++} v. 9 (the default compiler on Ubuntu
    20.04) is \Cpp{}14, but occasionally we'll enable \Cpp{}17/20/2b
    \begin{itemize}
    \item \code{g++ -std=c++17 \ddd}
    \end{itemize}
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{\code{auto}}

  Let the compiler deduce the type of a variable from the initializer, i.e. from
  the expression used to initialize the object

  \begin{codeblock}<2->{
auto z;                \uncover<3->{// error, no initializer
auto i = 0;            }\uncover<4->{// int
auto const f = 0.F;    }\uncover<5->{// float const
auto r = i + f;        }\uncover<6->{// float
auto c = Complex\{1,2\}; }\uncover<7->{// Complex
auto& rc = c;          }\uncover<8->{// Complex&
auto const& cri = i;   }\uncover<9->{// int const&
auto j = ri;           }\uncover<10->{// int - auto never deduces a reference
auto& g = f;           }\uncover<11->{// float const& - the constness is preserved
auto& rcr = c.r;       }\uncover<12->{// double&
auto& crcr = std::as_const(c).r; }\uncover<13->{// double const&}}\end{codeblock}

\end{frame}

\begin{frame}[fragile]{\code{auto}/trailing return type}

  \begin{itemize}
  \item When the return type of a function is \code{auto} the compiler will
    deduce it from the return statement(s)
    \begin{itemize}
    \item Only usable in a function definition
    \end{itemize}

    \begin{codeblock}
auto isqrt(int n)
\{
  int result;
  \ddd
  return result;
\}
\end{codeblock}

  \item<2-> If there are multiple return statements their expressions must have the
    same type
  \item<3-> Trailing return type
    \begin{codeblock}
int foo(\ddd);
auto foo(\ddd) -> int; // equivalent\end{codeblock}

  \end{itemize}

\end{frame}

\begin{frame}[fragile]{More data abstraction}

  Imagine to change the Complex type to use the polar form

  \begin{codeblock}
struct Complex \{
  double rho;
  double theta;
\};\end{codeblock}

  \begin{itemize}
  \item<2-> As a consequence, all client code has to change
    \begin{codeblock}
double norm2(Complex const& c) \{ return c.rho * c.rho; \}\end{codeblock}
  \item<3-> Not all combinations of $(\rho,\theta)$ are valid
    \begin{itemize}
    \item $\rho \geq 0, \theta \in [0, 2\pi)$
      \begin{codeblock}
Complex c\{-1, -1\}; // valid?
c.rho = -1;        // valid?\end{codeblock}
    \end{itemize}
  \end{itemize}

  \begin{itemize}
  \item<4-> We wish we could
    \begin{itemize}
    \item have more isolation between client code and implementation
    \item enforce an internal relation (\textit{class invariant}) between data
      members
    \end{itemize}
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Private representation, public interface}

  \begin{itemize}
  \item The internal representation of a data structure should be considered an
    implementation detail
  \item The manipulation of objects should happen through a
    well-defined function-based interface
  \item Known as \alert{encapsulation}
  \end{itemize}

\begin{codeblock}<2->{
\alert<2>{class} Complex \{
 \alert<2-4>{private}: // cartesian form
  double r;
  double i;
 \alert<2>{public}:
  // associated functions (member functions, also known as methods)
\};

\uncover<3->{Complex c\{1., 2.\}; // \alert<3>{error}}
\uncover<4->{double norm2(Complex const& c) \{
  return c\alert<4>{.r} * c\alert<4>{.r} + c\alert<4>{.i} * c\alert<4>{.i}; // \alert<4>{error}
\}}}\end{codeblock}

\end{frame}

\begin{frame}[fragile]{Construction}

  \begin{itemize}
  \item A special function, called \alert{constructor}, can be associated to a
    class to initialize the storage of an object of that type when it is created
  \item The constructor's name is the same as the class name
  \end{itemize}

  \begin{codeblock}<2->{
class \alert<2>{Complex} \{
 private:
  double r;
  double i;
 public:
  \alert<2>{Complex}(double x, double y)\only<2>{ // no return type}
  \uncover<3->{    : r\{x\}, i\{y\} // \alert<3>{member initialization list}}
  \{
    \uncover<4->{// nothing else to do}
  \}
  ...
\};

Complex c\{1., 2.\}; // or (1., 2.)}\end{codeblock}

\end{frame}

\begin{frame}[fragile]{Private representation, public interface \insertcontinuationtext}

  \begin{itemize}
  \item The internal representation of a class should be considered an
    implementation detail
  \item The manipulation of objects should happen through a
    well-defined function-based interface
  \end{itemize}

\begin{codeblock}
class Complex \{
 \alert<1>{private}:
  double r;
  double i;
 \alert<2>{public}:
  Complex(double x, double y) : r\{x\}, i\{y\} \{\}
  \visible<2->{double \alert<2>{real}() \{ return r; \}\only<2>{ // member function (method)}
  double \alert<2>{imag}() \{ return i; \}}
\};

double norm2(Complex c) \{
  return \only<1>{c\alert{.r} * c\alert{.r} + c\alert{.i} * c\alert{.i}; // \alert{error}}\only<2->{c\alert<2>{.real()} * c\alert<2>{.real()} + c\alert<2>{.imag()} * c\alert<2>{.imag()};}
\}\end{codeblock}

\end{frame}

\begin{frame}[fragile]{Private representation, public interface
    \insertcontinuationtext}

  \begin{itemize}
  \item Member functions (methods) can of course also mutate an object
    \begin{codeblock}
class Complex \{
 public:
  void add(Complex const& other) \{
    r += other.r;
    i += other.i;
  \}
  \ddd
\};

Complex c\{1., 2.\};
Complex d\{3., 4.\};
c.add(d);
c.real(); // 4.

\visible<2->{
c.add(Complex\{3., 4.\}); // valid
c.add(\{3., 4.\});        // also valid}\end{codeblock}

  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Private representation, public interface
    \insertcontinuationtext}

  \begin{itemize}
  \item Member functions that don't modify the object should be declared
    \textbf{\code{const}}

\begin{codeblock}
class Complex \{
 private:
  double r;
  double i;
 public:
  Complex(double x, double y) : r\{x\}, i\{y\} \{\}
  double real()\only<2>{ \alert{const}} \{ return r; \}\only<1>{ // could modify data members}
  double imag()\only<2>{ \alert{const}} \{ return i; \}
\};

double norm2(Complex \alert{const}& c) \{
  return c.real() * c.real() + c.imag() * c.imag();\only<1>{ // \alert{error}}
\}\end{codeblock}

  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Private representation, public interface
    \insertcontinuationtext}

  \begin{itemize}

  \item It's not rare to have functions with the same name, but in two different
    forms: one that reads and one that modifies the internal state
    \begin{itemize}
    \item Example of function overloading in action
    \end{itemize}

    \begin{codeblock}
class Complex \{
 public:
  double real()         const \{ return r; \}
  void   real(double d)       \{ r = d; \}
  \ddd
\};\end{codeblock}

    \begin{columns}
      \begin{column}{.5\textwidth}
        \begin{codeblock}
Complex c\{1.,2.\};
c.real(0.);
c.real();           // return 0.\end{codeblock}
      \end{column}
      \begin{column}{.5\textwidth}
        \begin{codeblock}
Complex const c\{1.,2.\};
c.real(0.);         // error
c.real();           // ok\end{codeblock}
      \end{column}
    \end{columns}
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Member vs free function}
  \begin{codeblock}
class Complex \{
 public:
  double norm2() const \{ // \alert<1>{member function}
    return r * r + i * i;
  \}
  ...
\};

double norm2(Complex const& c) \{ // \alert<1>{free function}
  return c.real() * c.real() + c.imag() * c.imag();
\}

Complex c\{\ddd\};
c.norm2(); // call the member function
norm2(c);  // call the free function\end{codeblock}

  \pause
  \begin{itemize}
  \item The public part of a class should ideally provide a safe, efficient and
    complete interface, yet minimal
  \item Prefer a free function, if possible
    \begin{itemize}
    \item Extend the functionality of a class without modifying existing code
    \end{itemize}
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Construction \insertcontinuationtext}

  \begin{codeblock}<1->{
class Complex \{
 private:
  double r\alt<4-5>{\alert{ = 0.}; // \alert{default member initializer}}{;}
  double i\alt<4-5>{\alert{ = 0.};}{;}
 public:
  \only<1>{


  }\only<2>{Complex(double x, double y) : r\{x\}, i\{y\} \{\}
  Complex(double x) : r\{x\}, i\{0.\} \{\}
  Complex() : r\{0.\}, i\{0.\} \{\} // \alert{default constructor}
  }\only<6->{Complex(double x \alert<6>{= 0.}, double y \alert<6>{= 0.})\only<6>{ // \alert{default arguments}}
       : r\{x\}, i\{y\} \{\}

  }\only<4-5>{Complex(double x, double y) : r\{x\}, i\{y\} \{\}
  Complex(double x) : r\{x\} \{\}
  Complex() \only<4>{\{\}}\only<5>{\alert{= default};}
  }\only<3>{Complex(double x, double y) : r\{x\}, i\{y\} \{\}
  Complex(double x) : Complex\{x, 0.\} \{\} // \alert{delegating constructor}
  Complex() : Complex\{0., 0.\} \{\}        // \alert{delegating constructor}
  }
\};

Complex c1\{1., 2.\};
Complex c2\{1.\}; // meaning \{1., 0.\}
Complex c3; // or \{\}, meaning \{0., 0.\}; () cannot be used here}\end{codeblock}

  \begin{itemize}
  \item<7-> A constructor should initialize the data members in order to
    establish the \textit{class invariant}
  \item<8-> The default constructor can be automatically generated by the
    compiler, but only if there are no other constructors
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{User-defined conversions with constructors}

  \begin{codeblock}
class Complex \{
  Complex(double x = 0., double y \alert<2-3>{= 0.}) : r\{x\}, i\{y\} \{\}
  \ddd
\};

double norm2(Complex const& c) \{ \ddd \}

norm2(1.);\uncover<2->{ // callable with a double (-> Complex)}
\uncover<3->{norm2(1);  // callable with an int (-> double -> Complex)}
\uncover<4->{c + 3;     // call operator+ with two Complex}
\uncover<5->{3 + c;     // call operator+ with two Complex, only if free function}\end{codeblock}

  \begin{itemize}
  \item<2-> The one-argument constructor is used for the conversion
  \item<6-> An \code{explicit} constructor prevents the implicit conversion
  \end{itemize}

  \begin{codeblock}<6->{
class Complex \{
  \alert{explicit} Complex(double x = 0., double y = 0.) \ddd
  \ddd
\};

norm2(1.);          // error
norm2(Complex\{1.\}); // ok}\end{codeblock}

\end{frame}

\begin{frame}[fragile]{\code{std::string} \insertcontinuationtext}

  \begin{itemize}

  \item A user-defined type to represent a sequence of characters
  \item Provided by the C++ Standard Library
  \item Provides (too) many member functions
    \begin{itemize}
    \item Construction
    \item Capacity (e.g. \code{size()}, \code{empty()})
    \item Assignment (e.g. \code{=}, \code{assign()})
    \item Comparison (\code{==}, \code{!=}, \code{<}, \code{>}, \code{<=}, \code{>=})
    \item Access to a character (e.g. \code{[]}, \code{back()}, \code{front()})
    \item Insertion/removal (e.g. \code{insert()}, \code{append()}, \code{erase()})
    \item Search (e.g. \code{find()})
    \item \ldots
    \end{itemize}
  \end{itemize}

\end{frame}

\begin{frame}{Example: rational numbers}

  \begin{itemize}
  \item Let's implement a class to represent rational numbers
  \item The representation is with two integers, such that
    \begin{itemize}
    \item The fraction is irreducible, i.e. their GCD (Greatest Common
      Denominator) is $1$
    \item If the number is negative the sign is kept in the numerator
    \item The denominator is different from $0$
    \end{itemize}
  \end{itemize}
\end{frame}


\begin{frame}{Class invariant}

  \begin{itemize}[<+->]
  \item A \textbf{class invariant} is a relation between the data members of a
    class that constrains the values that such members can assume
    \begin{itemize}
    \item It defines what is a valid state for an object of that class
    \item It must always hold for an object of that class
    \end{itemize}
  \item The invariant is established by the constructor
  \item The invariant is preserved by \textbf{public} methods
    \begin{itemize}
    \item The invariant holds when the function is entered $\implies$ the
      implementation can make assumptions
    \item The invariant may be violated during the execution of the function
    \item The invariant is re-established before exiting the function
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{\code{assert}}

  Check that a certain boolean expression is satisfied at run time
  \begin{itemize}
  \item for example, a class invariant at the end of a constructor or a
    condition at the beginning of a function (a \textit{pre-condition})
  \end{itemize}

  \begin{codeblock}<2->{
#include <cassert>

class Rational \{
  \ddd
  Rational(int num = 0, int den = 1) : n\{num\}, d\{den\} \{
    \ddd
    assert(std::gcd(n, d) == 1 && d > 0);
  \}
  Rational& operator/=(int n) \{
    assert(n != 0);
    \ddd
  \}
\};

bool operator==(Rational const& l, Rational const& r)
\{
  assert(std::gcd(l.num(), l.den()) == 1 && std::gcd(r.num(), r.den()) == 1);
  return l.num() == r.num() && l.den() == r.den();
\}}\end{codeblock}

\end{frame}

\begin{frame}[fragile]{\code{assert} \insertcontinuationtext}

  \begin{itemize}
  \item If the asserted condition is not satisfied, it means that the state of the
    program does not conform to the expectations of the programmer, i.e. to the
    design
  \item The state may even be corrupted $\rightarrow$ it's probably wiser to
    \code{terminate} the program as soon as possible to avoid causing damage
  \item Useful during testing/debugging
  \item Can be disabled for performance reasons (\code{g++ -DNDEBUG \ddd})
    \begin{itemize}
    \item Avoid side effects in \code{assert}s (e.g. assignments or calls to
      non-const methods), because they would disappear from the executable
    \end{itemize}
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{\code{assert} \insertcontinuationtext}

  \begin{itemize}
  \item \code{assert} (but also Doctest's \code{CHECK}) is a
    \textit{preprocessor macro}
  \item Macros obey syntactic rules that are different from those of C++ proper

    \begin{codeblock}<2->{
assert(Rational\{1\alert{,}2\} == Rational\{2\alert{,}4\});   // error (*)
assert(Rational\alert{(}1,2\alert{)} == Rational\alert{(}2,4\alert{)});   // ok
assert(\alert{(}Rational\{1,2\} == Rational\{2,4\}\alert{)}); // ok}\end{codeblock}

    {\tiny\begin{itemize}
    \item[*]<2-> macro "assert" passed 3 arguments, but takes just 1
    \end{itemize}}
  \item<3-> Macros \textit{expand} to arbitrary text, which is then passed to the
    real C++ compiler
  \item<3-> A bit more about the preprocessor later in the course
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Exceptions}

  \begin{itemize}
  \item Exceptions provide a general mechanism to:
    \begin{itemize}
    \item notify the occurrence of an error in the program execution
      \begin{itemize}
      \item using a \code{throw} expression
      \end{itemize}
    \item transfer control to a handler defined in a previous function in the call
      chain
      \begin{itemize}
      \item using a \code{try}/\code{catch} statement
      \end{itemize}
    \end{itemize}
  \item<2-> Exceptions help separate application logic from error management
  \item<3-> A typical use is in constructors and operators
  \item<4-> Exceptions cannot be ignored
    \begin{itemize}
    \item If a handler is not found the program is \code{terminate}d
    \end{itemize}
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Exceptions \insertcontinuationtext}
  \begin{columns}

    \begin{column}{.5\textwidth}
      \begin{codeblock}
struct E \{\};

auto low() \{
  \ddd // this part is executed
  \alert{throw} E\{\};
  \ddd // this part is not executed
\}

auto mid() \{
  \ddd // this part is executed
  low();
  \ddd // this part is not executed
\}

auto high() \{
  \alert{try} \{
    \ddd // this part is executed
    mid();
    \ddd // this part is not executed
  \} \alert{catch} (E& e) \{
    \ddd // use e
  \}
\}\end{codeblock}
    \end{column}

    \begin{column}{.5\textwidth}
      \begin{itemize}[<+->]
      \item An exception is an object
      \item After being raised (\code{throw}n), an exception is propagated up the stack
        of function calls until a suitable \code{catch} clause (handler) is
        found
      \item If no suitable handler (i.e. one compatible with the type of the
        exception) is found the program is \code{terminate}d
      \item Exceptions should be caught by (const) reference
      \item During \textit{stack unwinding} the stack frames are properly
        cleaned up
      \end{itemize}
    \end{column}

  \end{columns}

\end{frame}

\begin{frame}[fragile]{Exceptions in constructors}

  \begin{itemize}
  \item An exception is typically raised by a constructor to inform that it is
    not able to properly initialize the object
    \begin{itemize}
    \item i.e. it's not able to establish the class invariant
    \end{itemize}
  \item Let's apply this to Rational, using the standard-provided exception \code{std::runtime_error}
    \begin{itemize}
    \item it can be constructed with a string or a string literal
    \item it provides a \code{what()} method to retrieve that string, e.g. in
      the handler
    \end{itemize}
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Exceptions in constructors \insertcontinuationtext}

    \begin{codeblock}
#include <stdexcept>

class Rational \{
  \ddd
  Rational(int num = 0, int den = 1) : n\{num\}, d\{den\} \{
    if (d == 0) \{
      \alert{throw} std::runtime_error\{"denominator is zero"\};
    \}
    \ddd
  \}
\};

int main() \{
  \alert{try} \{
    Rational r1\{1,0\};
    \ddd
  \} \alert{catch} (std::runtime_error const& e) \{
    std::cerr << e.what() << \bslashn;
  \}
\}\end{codeblock}

\end{frame}

\begin{frame}{Assertions or exceptions?}

  \begin{itemize}
  \item There is no general rule, at best guidelines
  \item<2-> Use an assertion to express your belief about the state of a program
    \begin{itemize}
    \item E.g. a class invariant at the end of a constructor and at the
      beginning of a method
    \item Be generous with asserts
    \end{itemize}
  \item<3-> Use an exception to signal that a function can't perform its assigned
    task
    \begin{itemize}
    \item E.g. cannot establish the invariant, cannot allocate enough memory,
      cannot open a file, cannot connect to a web server, \ldots
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Assertions or exceptions? \insertcontinuationtext}

  \begin{itemize}
  \item Use an assertion to express a pre-condition for a function
    \begin{itemize}
    \item I.e. the function is able to perform its task only if its arguments
      satisfy certain constraints (and documents it)
    \item If the condition is not met, termination of the program is the best (or
      least worst) thing to do
    \item E.g. \code{Rational::operator/=} called with $0$
    \item The caller has the responsibility to call properly
    \item But if not meeting the condition is an acceptable situation, use an
      exception
    \end{itemize}
  \item Do \textbf{not} use an \code{assert} to validate input to the program
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{\code{operator@} in terms of \code{operator@=}}

  \begin{itemize}
  \item Typically, a symmetric \code{operator@} (e.g. \code{operator+}) is
    implemented in terms of a member \code{operator@=} (e.g. \code{operator+=})
    \begin{codeblock}
Complex operator+(Complex const& lhs, Complex const& rhs)
\{
  Complex result\{lhs\}; // create the result as a copy of lhs
  result += rhs;       // add rhs to the result
  return result;       // return it
\}\end{codeblock}

  \item<2-> Typically, \code{operator@=} returns a reference to the object being
    operated on

    \begin{codeblock}
class Complex \{
  \ddd
  Complex\alert{&} operator+=(Complex const& rhs) \{
    r += rhs.r; i += rhs.i;
    return \alert{*this};
  \}
\};\end{codeblock}

    \code{*this} means \textit{self}, see later in the course
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{The \code{switch} statement}

  The \code{switch} statement transfers control to one of multiple statements,
  depending on the value of a condition

  \begin{codeblock}<2->{
double compute(char op, double left, double right)
\{
  double result;

  switch (op) \{
    case \upquote{+}:
      result = left + right;
      break;
    \ddd
    case \upquote{/}:
      result = (right != 0.) ? left / right : 0.;
      break;
    default:
      result = 0.;
  \}

  return result;
\}}\end{codeblock}

\end{frame}

\begin{frame}{The \code{switch} statement \insertcontinuationtext}

  \begin{itemize}
  \item The condition is an expression whose evaluation gives an integral (or
    enumeration, see later) value
    \begin{itemize}
    \item Cannot switch on strings, for example
    \end{itemize}
  \item Each statement, possibly compound, is introduced either by a \code{case}
    label or by a \code{default} label
  \item Each \code{case} label specifies a unique integral constant
  \item Typically each statement is followed by a \code{break} statement, to
    jump after the \code{switch}, otherwise control \textit{falls through} the
    next instruction, even if this is part of a statement introduced by another
    label
    \begin{itemize}
    \item The compiler typically warns about falling through, but sometimes it's
      ok and the warning can be silenced with the \code{[[fallthrough]]}
      \textit{attribute}
    \end{itemize}
  \item There can be at most one \code{default} label, not necessarily at the
    end
  \item The same statement can be introduced by multiple \code{case} labels
  \end{itemize}

\end{frame}

\begin{frame}{Exercise}

  Write a function that takes two numeric operands of type double and one
  operator of type char and returns the result of applying that operator to the
  two operands.

  If either the operator is invalid or an operand is invalid, throw a
  user-defined exception that saves internally the operator character and the
  two operands and that has appropriate methods to retrieve them, so that the
  exception handler can print a meaningful error message.

\end{frame}
