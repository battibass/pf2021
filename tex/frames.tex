% !TeX root = ./pf2021.tex

%\includeonlyframes{current}

\begin{frame}{The language of a computer}
  \begin{itemize}[<+->]
  \item A \textit{computer} is a device that executes programs
  \item A \textit{program} is a collection of instructions to perform a specific
    task
  \item For a computer to understand instructions, these need to be expressed in a
    language that the computer can understand
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Binary language}

\begin{semiverbatim}
{\color{gray}\tikzref{markbit}0010\tikzref{markbyte}1001110110011000011111010111001011100111101100
11101000101001101011100111111100011101001000011010
00000110001101000011111010010001000101110000010010
00111011010111101101111110110011011111101100101101
10010010110011001101110011000011001011000001010010
11110100101111010001111001011000000000001111110100
1001110101100011010100\tikzref{ins}011100000001\tikzref{ins2}11000011\tikzref{ins3}01001101
00010001111001101000111100100110110110001101100100
01000110010111100011100010100101011011000110010001
10100011111101101000000000111101000001000100101101
11101100011010111001111110010101010110010010000100
00000010010011111010111011011101110011101100000111
00001001111011000000110000100110000101000100111011}\end{semiverbatim}

\uncover<2->{
  \uncover<2->{\tikz[overlay] \node[draw,rounded corners,thick,green,minimum
  width=3mm,minimum height=5mm,label={\color{green}bit}] (bit) at ([xshift=.5ex]markbit) {};}
  \uncover<3->{\tikz[overlay] \node[draw,rounded corners,thick,blue,minimum
  width=17mm,minimum height=7mm,label={45:{\color{blue}byte (8 bits)}}] (byte) at ([xshift=-.4ex]markbyte) {};}
  \uncover<4->{\tikz[overlay] \node[draw,rounded corners,thick,red,minimum width=49mm,minimum height=5mm] (instruction) at (ins) {};
  \tikz[overlay] \node[red] (description) at ([yshift=-32mm]instruction.south) {increment a number by 1 (for an x86_64)};
  \tikz[overlay] \draw[<-,red,thick] (instruction) -- (description);}
}

\end{frame}

\begin{frame}[fragile]{Programming language}
  \begin{itemize}
  \item<1-> A (high-level) programming language is an artificial language to write
    programs that is closer to humans
    \begin{columns}
      \begin{column}{.5\textwidth}
    \begin{codeblock}
int increment(int n)
\{
  return n + 1;
\}\end{codeblock}        
      \end{column}
      \begin{column}{.5\textwidth}
        {\smaller More or less equivalent to the function}
        \[
          \verb|increment|(n) = n + 1 \quad \forall n \in \mathbb{Z}
        \]
      \end{column}
    \end{columns}
\item<2-> Some form of translation needs to be applied to the program written in a
  high-level language to transform it into a program expressed in a binary
  language
\item<3-> To complicate things, the binary language is architecture-specific
  \begin{itemize}[<.->]
  \item Many architectures (Instruction Set Architectures -- ISA) have been
    defined over the years, many still in use
  \item i386, \textbf{x86_64}, SPARC, MIPS, \textbf{ARM}, VAX, Alpha, RiscV,
    PowerPC, \ldots
  \end{itemize}
\item<4-> The translation is done by other programs, notably \alert{compilers} and
  interpreters
\end{itemize}

\end{frame}

\begin{frame}{C++}

  \begin{itemize}[<+->]
  \item There are many programming languages, with very different characteristics
  \item Why \Cpp{}?
    \begin{itemize}[<.->]
    \item general purpose
    \item support for multiple styles of programming (\textit{paradigms})
    \item much used in scientific fields, but also in games, finance,
      telecommunications, embedded, \ldots
    \item available on all platforms
    \item efficient
    \item ISO standard
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Many types of computers}

  \begin{columns}

    \begin{column}{.5\textwidth}

      \includegraphics[width=\textwidth]{images/samsung-gear-compressed.jpeg}

      \begin{center}
        {\tiny(from \url{https://www.samsung.com/})}
      \end{center}
    \end{column}

    \begin{column}{.5\textwidth}
      \includegraphics[width=\textwidth]{images/gear2-ifixit.jpg}

      \begin{center}
        {\tiny (from \url{https://www.ifixit.com/})}
      \end{center}
    \end{column}

  \end{columns}

\end{frame}

\begin{frame}{Many types of computers \insertcontinuationtext}
  \includegraphics[width=\textwidth]{images/rpi-compressed.png}

  {\tiny (from \url{https://www.raspberrypi.org/})}
\end{frame}

\begin{frame}{Many types of computers \insertcontinuationtext}
  \includegraphics[width=\textwidth]{images/desktop.jpg}
\end{frame}

\begin{frame}{Many types of computers \insertcontinuationtext}
  \includegraphics[width=\textwidth]{images/fugaku.jpg}

  {\tiny (from \url{https://www.riken.jp/en/})}
\end{frame}

\begin{frame}{The Von Neumann architecture}

  \begin{center}

    \vskip -.8cm

    \begin{tikzpicture}[every text node part/.style={align=center}]
      \uncover<3->{
        \node[rectangle,draw,thick,minimum height=4cm,minimum width=2.1cm,fill=yellow,"Memory"] (memory) {
          data \\ + \\ instructions
        };
        \node[above=20pt of memory,inner sep=0pt,outer sep=0pt] (ram) {\includegraphics[height=1cm]{images/ram.jpg}};
      }
      \uncover<2->{
        \node[rectangle,black,draw,thick,minimum height=4cm,minimum width=2.5cm,fill=red!80!black,right=of memory,"CPU"] (cpu) {};
        \node[rectangle,black,draw,thick,text width=2cm,minimum
        height=1cm,fill=white,below=10pt of cpu.north,inner sep=0pt,outer sep=0pt] (alu) {\scriptsize
          Arithmetic-Logic Unit};
        \node[rectangle,black,draw,thick,minimum width=2cm,fill=white,above=of cpu.south] (control) {\scriptsize Control};
        \path (alu) -- (control) node[midway,rectangle,black,draw,thick,minimum width=2cm,fill=white] (registers) {\scriptsize Registers};
        \node[above=20pt of cpu,inner sep=0pt,outer sep=0pt] (intel) {\includegraphics[height=1cm]{images/cpu.jpg}};
      }
      \uncover<3->{\draw[<->,thick] (memory) -- (cpu);}
      \uncover<4->{
        \node[tape,draw,thick,minimum height=1.5cm,minimum width=2cm,fill=green,right=of cpu.north east,yshift=-1cm] (input) {Input};
        \node[tape,draw,thick,minimum height=1.5cm,minimum width=2cm,fill=green,right=of cpu.south east,yshift=1cm] (output) {Output};
        \draw[<-,thick] (cpu) -- (input);
        \draw[->,thick] (cpu) -- (output);
        \node[above=of input,outer sep=0pt,inner sep=0pt] (keyboard) {\includegraphics[height=1cm]{images/keyboard.png}};
        \node[right=0pt of keyboard] (mouse) {\includegraphics[height=1cm]{images/mouse.jpg}};
        \node[below right=0pt and 0pt of mouse,xshift=-.5cm] (monitor) {\includegraphics[height=1cm]{images/monitor.png}};
        \node[below=0pt of monitor] (harddisk) {\includegraphics[height=1cm]{images/harddisk.jpg}};
        \node[below=0pt of harddisk] (usb-stick) {\includegraphics[height=1cm]{images/usb-stick.png}};
        \node[below=0pt of usb-stick] (router) {\includegraphics[height=1cm]{images/router.jpg}};
        \node[below left=0pt and 0pt of router] (gpu) {\includegraphics[height=1cm]{images/gpu.jpg}};
        \node[left=0pt of gpu] (sensor) {\includegraphics[height=1cm]{images/sensor.jpg}};
      }
    \end{tikzpicture}
  \end{center}

\end{frame}

\begin{frame}{The Von Neumann architecture \insertcontinuationtext}

  \begin{itemize}[<+->]
  \item Imagine memory as a looooong tape divided into locations whose content
    you can read and write
  \item Each memory location is identified by an index
    \begin{itemize}[<.->]
    \item e.g. location at position 8'363'944
    \end{itemize}
  \item Programs and the data they manage stay both in memory, typically in
    different regions
  \item The CPU fetches instructions from memory into its registers and executes
    them
  \item Typical instructions:
    \begin{itemize}[<.->]
    \item read data from memory into registers
    \item write data from registers to memory
    \item manipulate data in registers
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Also data are binary}

  \begin{semiverbatim}
{\color{gray}00101001110110011000011111010111001011100111101100
11101000101001101011100111111100011101001000011010
00000110001101000011111010010001000101110000010010
00111011010111101101111110110011011111101100101101
10010010110011001101110011000011001011000001010010
11110100101111010001111001011000000000001111110100
1001110110001101101001\tikzref{ins}0110000101101111000000001101
00010001111001101000111100100110110110001101100100
01000110010111100011100010100101011011000110010001
10100011111101101000000000111101000001000100101101
11101100011010111001111110010101010110010010000100
00000010010011111010111011011101110011101100000111
00001001111011000000110000100110000101000100111011}\end{semiverbatim}

\uncover<2->{
  \tikz[overlay] \node[draw,thick,rounded corners,red,minimum width=65mm,minimum
  height=5mm] (data) at (ins) {};
  \tikz[overlay] \node[red] (description) at ([yshift=-35mm]data.south)
  {\only<3>{integer number 1667850607?}\only<4>{floating-point
      number $4.30511 \times 10^{21}$?}\only<5>{character string "ciao"?}};
}

\end{frame}

\begin{frame}[fragile]{A minimal C++ program}

  \begin{itemize}
  \item This program does nothing, successfully (details will be explained)
    \begin{codeblock}
int main() \{\}\end{codeblock}

  \item<2-> Let's write these 13 characters (including spaces) in a
    \alert{source file}, which we call \code{minimal.cpp}

  \begin{shellblock}<3->{
\$\tikzref{prompt} \uncover<4->{code minimal.cpp\tikzref{command}} \uncover<5->{\inserthitenter\tikzref{hitnewline}}
\uncover<6->{\$ cat minimal.cpp \inserthitenter
int main() \{\}
\$}}\end{shellblock}

\uncover<3>{\tikz[remember picture,overlay] \draw[<-,white] ([xshift=1ex] prompt) -- +(1,0) node[white,right] {\scriptsize this is the shell prompt};}
\uncover<4>{\tikz[remember picture,overlay] \draw[<-,white] ([xshift=1ex] command) -- +(1,0) node[white,right] {\scriptsize this is the command you write};}
\uncover<5>{\tikz[remember picture,overlay] \draw[<-,white] ([xshift=1ex] hitnewline) -- +(1,0) node[white,right] {\scriptsize you hit the ``Enter'' key on the keyboard};}

  \item<7> Before \alert{executing} the program we need to translate it into
    the language of the computer
  
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{A minimal C++ program \insertcontinuationtext}

  \begin{itemize}

  \item In C++ the translation into a binary format is the job of the compiler,
    which produces an \alert{executable} file

\begin{center}
    \begin{tikzpicture}[every text node part/.style={align=center}]
      \node[tape,tape bend height=.3cm,draw,thick,inner sep=2pt,minimum height=2cm,minimum width=3cm] (source) {Source file \\ {\scriptsize(\code{minimal.cpp})}};
      \node[tape,tape bend height=.3cm,black,draw,thick, inner sep=2pt,minimum height=2cm,minimum width=3cm,right=3cm of source] (exe) {Executable binary file \\ {\scriptsize(\code{a.out})}};
      \draw[->] (source) -- (exe) node[above,align=center,midway] {Compilation \\ {\scriptsize(\code{g++})}};
    \end{tikzpicture}
  \end{center}

  \begin{shellblock}<2->{
\$ g++ minimal.cpp
\$ \uncover<3->{ls
a.out  minimal.cpp
\$ }\uncover<4->{./a.out\tikzref{program}
\$ }\uncover<5->{g++ minimal.cpp -o minimal
\$ ls
a.out  minimal  minimal.cpp
\$ }\uncover<6->{./minimal
\$ }}\end{shellblock}

  \uncover<4>{\tikz[remember picture,overlay] \draw[<-,white] ([xshift=1ex] program) -- +(1,0) node[white,right] {\scriptsize this command executes the program};}

  \item<7-> The \code{-o} option passed to the \code{g++} command allows to give
    another name to the final executable
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Spaces}

  \begin{itemize}
  \item Spaces are (almost) irrelevant
  \end{itemize}

  \begin{columns}[T]
  \begin{column}{.3\textwidth}<2->
    \begin{codeblock}
int main()\{\}

\end{codeblock}
  \end{column}

  \begin{column}{.3\textwidth}<3->
    \begin{codeblock}
int
main(  ) \{
   \}\end{codeblock}
  \end{column}

  \begin{column}{.3\textwidth}<4->
    \begin{codeblock}
int\tikzref{n1}main()\{ \}

    \end{codeblock}
  \end{column}

  \uncover<5->{
\begin{tikzpicture}[remember picture,overlay]
  \node[circle,radius=7pt,draw,red,line width=1pt,opacity=.7] at (n1) (n2){};
  \node[above=of n2,draw=red,line width=1pt,opacity=.7,rounded corners] {space needed here} edge[->,line width=1pt,red,opacity=.7] (n2);
\end{tikzpicture}
  }

\end{columns}

\begin{itemize}[<6->]
\item Tools exist to consistently format source code to improve readability
  \begin{itemize}
  \item They are customizable
  \item You are required to use them
  \end{itemize}
\end{itemize}

\begin{columns}[T]
  \begin{column}{.4\textwidth}
    \begin{shellblock}<7->{
\$ clang-format minimal.cpp
int main()
\{
\}
\$}\end{shellblock}
  \end{column}

  \begin{column}{.6\textwidth}
  \begin{codeblock}<8->{
# .clang-format file
\ldots
AllowShortFunctionsOnASingleLine: false
BraceWrapping:
  AfterFunction:   true
  \ldots}\end{codeblock}
  \end{column}
\end{columns}

\end{frame}

\begin{frame}[fragile]{Syntax check}

  \begin{itemize}
  \item The compiler can translate a program into a binary executable only if the
    code is syntactically correct

  \begin{codeblock}<2->{
intmain() \{\}}\end{codeblock}

  \begin{shellblock}<2->{
\$ g++ minimal.cpp
minimal.cpp:1:9: error: ISO C++ forbids declaration of \upquote{intmain} with \ldots
    1 | intmain() \{\}
      |         ^
\$}\end{shellblock}

  \item<3-> Error messages are usually precise about the cause of the error, but
    not always
  \item<3-> Learn to interpret error messages
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Comments}

  \begin{itemize}

  \item Code can contain comments

    \begin{codeblock}<2->{
int main() \alert{//} comment until the end of the line
\{
\}}\end{codeblock}

    \begin{codeblock}<3->{
int main()
\{
  \alert{/*} possibly multi-line comment
     that goes until the final marker
     and cannot nest \alert{*/}
\}}\end{codeblock}

  \item<4-> Comments are ignored by the compiler and are equivalent to spaces
  \item<4-> Comment are for humans
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Basic notions of Input and Output}

  \begin{itemize}
  \item The input and output system allows a program to interact with the
    external world
  \item One mechanism offered by C++ to do input and output is the \textit{I/O
      streams} interface, which allows the creation and the manipulation of
    \textit{stream} entities
    \begin{itemize}
    \item Values are extracted from an input stream
    \item Values are inserted into an output stream
    \end{itemize}
  \item Input and output streams connected to the terminal are automatically
    available to a program
    \begin{itemize}
    \item \code{std::cin}, \code{std::cout} (and \code{std::cerr} for errors)
    \end{itemize}
  \item To extract and insert values, use the stream \textit{operators}
    \code{>>} and \code{<<}, respectively
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Hello}

  A less minimal C++ program (details will be explained)

  \begin{codeblock}
\alert<2>{#include <iostream>}\uncover<2->{ // import I/O utilities}
\alert<2>{#include <string>}\uncover<2->{ // import string utilities}

int \alert<3>{main}()\uncover<3->{ // start the program from here}
\{
\alert<4>{  std::cout <{}< "What\textquotesingle{}s your name? ";}\uncover<4->{ // print a message on the terminal}
\alert<5>{  std::string name;}\uncover<5->{ // some space is needed in memory for a string}
\alert<6>{  std::cin >{}> name;}\uncover<6->{ // read a string from the terminal into that space}
\alert<7>{  std::cout <{}< "Hello, " <{}< name <{}< \bslashn{};}\uncover<7->{ // print a multi-part message}
\}\end{codeblock}

\begin{shellblock}<8->{
\uncover<8->{\$ g++ hello.cpp -o hello \inserthitenter
\$ }\uncover<9->{./hello \inserthitenter
What\textquotesingle{}s your name? }\uncover<10->{Francesco \inserthitenter
Hello, Francesco
\$ }}\end{shellblock}

\end{frame}

\begin{frame}{Objects}

  \begin{itemize}[<+->]
  \item The constructs in a C++ program create, destroy, refer to, access,
    and manipulate \alert<.>{objects}
  \item An object is a region of storage (i.e. memory)
    \begin{itemize}[<+->]
    \item has a \alert<.>{storage duration}/\alert<.>{lifetime}
    \item has a \alert<.>{type}
    \item can have a \alert<.>{name}
    \end{itemize}
  \end{itemize}

\end{frame}

\begin{frame}{Types}

  \begin{itemize}[<+->]
  \item A type gives meaning to a piece of storage
    \begin{itemize}
    \item What's the meaning of a piece of storage that contains $01100011011010010110000101101111$?
    \item Read as a sequence of alphabetic characters, it's the letters
      \textit{c}, \textit{i}, \textit{a}, \textit{o}
    \item Read as an integer number, it's $1667850607$
    \item Read as a floating-point number, it's about $4.30511 \times 10^{21}$
    \end{itemize}
  \item A type identifies a set of values and the operations that can be applied
    to those values
    \begin{itemize}
    \item C++ is a \alert{strongly typed} language (mostly)
    \end{itemize}
  \item The compiler checks that program instructions are compatible with the type system
    \begin{itemize}
    \item C++ is a \alert{statically typed} language (mostly)
    \end{itemize}
  \item A type is also associated with a machine representation for
    the values belonging to the type
  \item C++ defines a few fundamental types and provides mechanisms to build
    compound types on top of them
  \end{itemize}

\end{frame}

\begin{frame}{Fundamental types}
  \begin{itemize}
    \item arithmetic types
      \begin{itemize}
        \item integral types
          \begin{itemize}
          \item signed integer types: \code{short int}, \alert<3->{\code{int}},
            \code{long int}, \code{long long int}
          \item unsigned integer types: \code{unsigned short int},
            \code{unsigned int}, \code{unsigned long int}, \code{unsigned long
              long int}
          \item character types: \alert<3->{\code{char}}, \code{signed char},
            \code{unsigned char}, \ldots
          \item boolean types: \alert<3->{\code{bool}}
          \end{itemize}
        \item floating-point types: \code{float}, \alert<3->{\code{double}}, \code{long double}
      \end{itemize}
    \item \code{std::nullptr_t}
    \item \code{void}
  \end{itemize}

  \pause

  In general, size and machine representation are not defined by the
  standard

\end{frame}

\begin{frame}[fragile]{\code{int}}

  \begin{columns}
    \begin{column}{.8\textwidth}
      Type representing a signed integer number

      \begin{itemize}
      \item<2-> Set of values: subset of $\mathbb{Z}$
      \item<3-> Operations: addition, subtraction, multiplication, division,
        remainder, comparisons, \ldots
      \item<4-> Representation: 2's complement
      \item<5-> With N bits, values are in the range $[-2^{N-1}, 2^{N-1}-1]$
      \item<6-> Intended to have the natural size suggested by the architecture.
        Typical size is 32 bits (4 bytes)
        \begin{itemize}
        \item $[-2$ $147$ $483$ $648, +2$ $147$ $483$ $647]$
        \end{itemize}
      \end{itemize}
    \end{column}
    \hfill
    \begin{column}{.2\textwidth}
      \uncover<4->{\begin{tabular}{ r | r }
        7 & \alert{0}111 \\
        6 & \alert{0}110 \\
        5 & \alert{0}101 \\
        4 & \alert{0}100 \\
        3 & \alert{0}011 \\
        2 & \alert{0}010 \\
        1 & \alert{0}001 \\
        0 & \alert{0}000 \\
        -1 & \alert{1}111 \\
        -2 & \alert{1}110 \\
        -3 & \alert{1}101 \\
        -4 & \alert{1}100 \\
        -5 & \alert{1}011 \\
        -6 & \alert{1}010 \\
        -7 & \alert{1}001 \\
        -8 & \alert{1}000
      \end{tabular}}
    \end{column}
  \end{columns}

\end{frame}

\begin{frame}[fragile]{Variables}

  \begin{itemize}
  \item A variable is a \alert{name} for an \textit{object}
  \item A name is an \textit{identifier}: a sequence of letters (including
    \code{_}) and digits, starting with a letter
    \begin{itemize}
    \item Avoid \code{_} at the beginning
    \item Choose meaningful names
    \end{itemize}
  \end{itemize}

  \begin{codeblock}<2->{
\uncover<2->{int i;            // declaration}\uncover<3->{; the value is undefined}
\uncover<4->{i = 4321;         // assignment of a constant}
\uncover<5->{int j = 1234;     // declaration and initialization}
\uncover<6->{i = j;            // assignment of j\textquotesingle{}s value to i}}\end{codeblock}

  \begin{tikzpicture}[
      mem/.style={
        node font=\ttfamily\scriptsize,
        minimum height=.5cm,
      },
      location/.style={
        mem,
        draw=black!50,
        minimum width=1.2cm,
        fill=green!20!white,
      },
      every node/.style={
        mem,
      },
      anchor=south west,
      node distance=0,
    ]
    \clip (0.1,-1) rectangle (\textwidth-0.1cm,1.5);
    %% \visible<3->{\draw[step=.5cm,gray,thin,dashed] (0, .1cm) grid (\textwidth,0.4cm);}
    \visible<2->{\node at (0,0) [mem,draw=black!50,minimum width=\textwidth,
        "Memory" above] {};}
      \visible<2->{\node at (2,0) [location, "i" below] {
          \alt<-2>{}{\alt<3>{?}{\alt<4-5>{4321}{1234}}}};}
        \visible<5->{\node at (7,0) [location, "j" below] {1234};}
  \end{tikzpicture}

  \uncover<7->{NB At the end \code{i} and \code{j} have the same value but remain
  \alert{distinct} objects}

\end{frame}

\begin{frame}{Keywords}

  The following identifiers are reserved
  \vskip .5cm

  {
    \setbeamerfont{localfont}{size=\scriptsize,family=\tt}
    \usebeamerfont{localfont}

    \begin{tabular}{l l l l l l}
      alignas  & const        & for       & private          & throw    \\
      alignof  & constexpr    & friend    & protected        & true     \\
      and      & const_cast   & goto      & public           & try      \\
      and_eq   & continue     & if        & register         & typedef  \\
      asm      & decltype     & inline    & reinterpret_cast & typeid   \\
      auto     & default      & int       & return           & typename \\
      bitand   & delete       & long      & short            & union    \\
      bitor    & do           & mutable   & signed           & unsigned \\
      bool     & double       & namespace & sizeof           & using    \\
      break    & dynamic_cast & new       & static           & virtual  \\
      case     & else         & noexcept  & static_assert    & void     \\
      catch    & enum         & not       & static_cast      & volatile \\
      char     & explicit     & not_eq    & struct           & xor      \\
      char16_t & export       & nullptr   & switch           & xor_eq   \\
      char32_t & extern       & operator  & template         & wchar_t  \\
      class    & false        & or        & this             & while    \\
      compl    & float        & or_eq     & thread_local
    \end{tabular}
  }
\end{frame}

\begin{frame}{Literals}

  A literal is a constant \textbf{value} of a certain \textbf{type} included in
  the source code

  \pause

  \begin{itemize}
  \item integer
  \item floating point
  \item character
  \item string
  \item boolean
  \item \code{nullptr}
  \end{itemize}

\end{frame}

\begin{frame}{Integer literals}

  \begin{description}[<+->]
  \item[decimal] non-\code{0} decimal digit followed by zero or more digits
    \begin{itemize}[<.->]
    \item \code{1 -98 123456789 -1\textquotesingle{}234\textquotesingle{}567\textquotesingle{}890}
    \end{itemize}
  \item[binary] \code{0b} or \code{0B} followed by binary digits
    \begin{itemize}[<.->]
    \item \code{0b1101111010101101 0B111\textquotesingle{}0101\textquotesingle{}1011\textquotesingle{}1100\textquotesingle{}1101\textquotesingle{}0001\textquotesingle{}0101}
    \end{itemize}
  \item[exadecimal] \code{0x} or \code{0X} followed by hexadecimal digits
    \begin{itemize}[<.->]
    \item \code{-0xdead 0xDEad123f 0XdeAD\textquotesingle{}123F}
    \end{itemize}
  \item[octal] \code{0} followed by octal digits
    \begin{itemize}[<.->]
    \item \code{01 -077 07\textquotesingle{}654\textquotesingle{}321}
    \item N.B. A \code{0} in front of a number is meaningful!
    \end{itemize}
  \end{description}

  \uncover<+->{Integer literals are of type \code{int}}

\end{frame}

\begin{frame}[fragile]{\code{std::string}}

  \begin{itemize}[<+->]

  \item A \textit{compound} (\textit{user-defined}) type to represent a
    string of characters
  \item Provided by the C++ Standard Library
  \item Many operations available
  \item An \code{std::string} can be initialized with a string literal, a
    sequence of escaped or non-escaped characters between double quotes
    \begin{itemize}[<.->]
    \item \code{"hello" "hello\bslashn{}world" "hello
        \bslash{"}world\bslash{"}"}
    \item \code{\bslash{}n} means ``newline''
    \end{itemize}
  \item The type of a string literal is \textbf{not} \code{std::string}
  \end{itemize}

  \begin{codeblock}<+->{
std::string corso = "Programmazione per la Fisica";
\uncover<+->{corso = corso \tikzref{strplusref}+ "\bslash{n}Anno Accademico 2021/2022";}}\end{codeblock}

\uncover<+->{
  \begin{tikzpicture}[remember picture,overlay]
    \node[draw=red,line width=1pt,opacity=.7,rounded corners, minimum
    width=1.5ex] at ([xshift=.5ex]strplusref) (strplusbox) {};
    \node[below=of strplusbox,draw=red,line width=1pt,opacity=.7,rounded
    corners] {concatenate} edge[->,line width=1pt,red,opacity=.7] (strplusbox)
    {};
  \end{tikzpicture}
}

\end{frame}

\begin{frame}[fragile]{Expressions}

  \begin{itemize}
  \item An expression is a sequence of operators and their operands
    that specifies a computation
  \item Literals and variables are typical operands, but there are others

  \begin{codeblock}<2->{
\uncover<2->{1 + 2}
\uncover<3->{\alert<8->{i = 1 + 2}       // assignment}
\uncover<4->{i == j          // equality comparison}
\uncover<5->{sqrt(x) > 1.42}
\uncover<6->{\alert<8->{std::cout <{}< "hello, " <{}< name <{}< \upquote{\bslash{}n}}}}\end{codeblock}

\item<7-> The evaluation of an expression typically produces a result
\item<8-> Some expressions have \textit{side-effects}
  \begin{itemize}
  \item They modify the state of the program, i.e. the state of memory, or the
    external world
  \end{itemize}

\end{itemize}

\end{frame}

\begin{frame}[fragile]{Operators}

  \begin{columns}[t]

    \column{0.12\textwidth}
    {\scriptsize Arithmetic}
    \begin{codeblock}
+a
-a
a + b
a - b
a * b
a / b
a % b
~a
a & b
a | b
a ^ b
a {<}< b
a {>}> b\end{codeblock}

    \column{0.12\textwidth}
    \centering{\scriptsize Logical}
    \begin{codeblock}
!a
a && b
a || b\end{codeblock}

    \column{0.13\textwidth}
    \centering{\scriptsize Comparison}
    \begin{codeblock}
a == b
a != b
a {<} b
a {>} b
a {<}= b
a >= b\end{codeblock}

    \column{0.13\textwidth}
    \centering{\scriptsize Increment}
    \begin{codeblock}
++a
{-}-a
a++
a{-}-\end{codeblock}

    \column{0.14\textwidth}
    \centering{\scriptsize Assignments}
    \begin{codeblock}
a = b
a += b
a -= b
a *= b
a /= b
a %= b
a &= b
a |= b
a ^= b
a <{}<= b
a >{}>= b\end{codeblock}

    \column{0.09\textwidth}
    \centering{\scriptsize Access}
    \begin{codeblock}
a[b]
*a
&a
a->b
a.b\end{codeblock}

    \column{0.09\textwidth}
    \centering{\scriptsize Other}
    \begin{codeblock}
a(\ddd)
a, b
? :\end{codeblock}

  \end{columns}

  \vskip .5cm % bleah!

  Plus: casts, allocation and deallocation, static introspection, \ldots

  \begin{itemize}[<+->]
  \item Rules exist for associativity, commutativity and precedence
    \begin{itemize}
    \item When in doubt use parentheses
    \end{itemize}
  \item Many operators can be \alert{overloaded} for user-defined
    types
    \begin{itemize}[<.->]
    \item e.g. \code{+} to concatenate strings
    \end{itemize}
  \end{itemize}

\end{frame}

\begin{frame}{Algorithm}

  A finite sequence of precisely defined steps to solve a problem

\end{frame}

\begin{frame}<1-2>[fragile,label=firstexample]{Sum of two numbers}

  A program that reads two numbers from input and writes their sum to output

  \begin{columns}[T]
    \begin{column}{.5\textwidth}
      \centering
  \uncover<2->{
    \begin{tikzpicture}
      [auto,
      startstop/.style = {rectangle, rounded corners=5pt, draw=black, thick, node font=\scriptsize,
        text width=4em, align=flush center},
      inout/.style     = {trapezium, trapezium left angle=60,trapezium right angle=120, thick, draw=green, fill=green!20,
        text width=4em, align=flush center, node font=\scriptsize},
      block/.style     = {rectangle, draw=blue, thick, fill=blue!20,align=center, rounded corners=2pt,
        text width=4em, align=flush center, node font=\scriptsize},
      decision/.style  = {diamond, aspect=1.5, draw=red, thick, fill=red!20, text width=4em, align=flush center, inner sep=1pt, node font=\scriptsize},
      line/.style      = {draw, thick, -latex, shorten >=2pt}]
      \matrix [column sep=5mm,row sep=4mm]
      {
        % row 1
        \node [startstop] (start) {start}; \\
        % row 2
        \node [inout] (in) {read a, b}; \\
        % row 3
        \node [block,text width=7em] (result) {result $\leftarrow$ a + b}; \\
        % row 4
        \node [inout] (out) {write result}; \\
        % row 5
        \node [startstop] (stop) {stop}; \\
      };
      \begin{scope}[every path/.style=line]
        \path (start)  -- (in);
        \path (in)     -- (result);
        \path (result) -- (out);
        \path (out)    -- (stop);
      \end{scope}
    \end{tikzpicture}
  }
    \end{column}
    \begin{column}{.5\textwidth}
      \begin{codeblock}<3->{
#include <iostream>

int main()
\{
  \uncover<4->{\alert<4>{int a;
  int b;
  std::cin >{}> a >{}> b;}}
  \uncover<5->{\alert<5>{int result = a + b;}}
  \uncover<6->{\alert<6>{std::cout <{}< result <{}< \bslashn;}}
\}}\end{codeblock}

    \end{column}
  \end{columns}

  \uncover<7->{}
\end{frame}

\begin{frame}{Statement}
  Statements are units of code that are executed in sequence

  \begin{itemize}
  \item expression statement
  \item compound statement or block
  \item declaration statement
  \item selection statement
  \item iteration statement
  \item jump statement
  \item \ldots
  \end{itemize}

\end{frame}

\againframe<3->{firstexample}

\begin{frame}[fragile]{Expression statement}

  \begin{itemize}[<+->]
  \item An expression followed by a semicolon (\code{;})
  \item The value of the expression (if any) is discarded
  \item The expression can have side effects
  \end{itemize}

  \begin{codeblock}
\uncover<1->{b + 2;}
\uncover<3->{a = b + 2;
std::cin >{}> a >{}> b;}
\uncover<4->{; // empty statement}\end{codeblock}

\end{frame}

\begin{frame}[fragile]{Compound statement (or block)}

  A sequence of zero or more statements enclosed between braces
  (\code{\{\}})

  \begin{codeblock}
\{
   found = true;
   ++i;
   int n = 3;
   std::cout <{}< n;
\}\end{codeblock}

  \begin{codeblock}
\{ found = true; ++i; \ddd \} // all on one line\end{codeblock}

\end{frame}

\begin{frame}{Declaration statement}

  \begin{itemize}[<+->]
  \item A declaration statement introduces one or more new identifiers into a
    \Cpp{} program, possibly initializing them
    \begin{itemize}
    \item typically variables, but not only
    \end{itemize}

  \item A declaration of a \textbf{variable} in a \textbf{block} makes the
    variable of \alert{automatic storage duration}, unless otherwise specified
    \begin{itemize}
    \item the corresponding object is automatically created each time the
      declaration is executed
    \item<.-> the corresponding object is automatically destroyed each time the
      execution reaches the end of the block
    \end{itemize}

  \item A declaration should introduce only one identifier

  \item A variable should be declared only in the moment it's actually needed

  \item A variable should be initialized at the point of declaration, if there
    is a meaningful initial value

  \end{itemize}

\end{frame}

\begin{frame}[fragile]{The smallest of two numbers}

  A program that reads two numbers from input and writes the smallest to output

  \begin{columns}[T]
    \begin{column}{.5\textwidth}
  \uncover<2->{
    \begin{tikzpicture}
      [auto,
      startstop/.style = {rectangle, rounded corners=5pt, draw=black, thick, node font=\scriptsize,
        text width=3em, align=flush center},
      inout/.style     = {trapezium, trapezium left angle=60,trapezium right angle=120, thick, draw=green, fill=green!20,
        text width=4em, align=flush center, node font=\scriptsize},
      block/.style     = {rectangle, draw=blue, thick, fill=blue!20,align=center, rounded corners=2pt,
        text width=5em, align=flush center, node font=\scriptsize},
      decision/.style  = {diamond, aspect=1.5, draw=red, thick, fill=red!20, text width=4em, align=flush center, inner sep=1pt, node font=\scriptsize},
      line/.style      = {draw, thick, -latex, shorten >=2pt}]
      \matrix [column sep=0mm,row sep=4mm,ampersand replacement=\&]
      {
        % row
        \& \node [startstop] (start) {start}; \\
        % row
        \& \node [inout] (in) {read a, b}; \\
        % row
        \& \node [decision] (less) {a < b}; \\[-4mm]
        % row
        \node [block] (a) {result $\leftarrow$ a}; \&
        \& \node [block] (b) {result $\leftarrow$ b}; \\
        % row
        \& \coordinate (join); \\
        % row
        \& \node [inout] (out) {write result}; \\
        % row
        \& \node [startstop] (stop) {stop}; \\
      };
      \begin{scope}[every path/.style=line]
        \path (start)  -- (in);
        \path (in)     -- (less);
        \path (less)   -| node [near start,above] {\scriptsize{yes}} (a);
        \path (less)   -| node [near start,above] {\scriptsize{no}} (b);
        \path[-,shorten >=0pt] (a)   |- (join);
        \path[-,shorten >=0pt] (b)   |- (join);
        \path (join) -- (out);
        \path (out)    -- (stop);
      \end{scope}
    \end{tikzpicture}
  }
    \end{column}
    \begin{column}{.5\textwidth}
      \begin{codeblock}<3->{
#include <iostream>

int main()
\{
  \uncover<4->{\alert<4>{int a;
  int b;
  std::cin >{}> a >{}> b;}}
  \uncover<9->{\alert<9>{int result;}}
  \uncover<5->{\alert<5>{if (a < b) \{}
    \uncover<6->{\alert<6>{\only<-8>{int }result = a;}}
  \alert<5>{\} else \{}
    \uncover<6->{\alert<6>{\only<-8>{int }result = b;}}
  \alert<5>{\}}}
  \uncover<7->{\alert<7>{std::cout <{}< result <{}< \bslashn;}}\uncover<8>{\alert<8>{ // error}}
\}}\end{codeblock}

    \end{column}
  \end{columns}

  \uncover<10->{}

\end{frame}

\begin{frame}[fragile]{\code{if then else}}

  \begin{itemize}
  \item<1-> Selection statement to choose one of two flows of control depending on a
    boolean condition
  \item<2-> Two (basic) forms:
    \begin{itemize}
    \item<3-> \code{if (} \textit{condition-expr} \code{)} \textit{statement} \code{else} \textit{statement}
    \item<4-> \code{if (} \textit{condition-expr} \code{)} \textit{statement}
    \end{itemize}

  \begin{columns}[t]

    \begin{column}{.45\textwidth}

      \begin{codeblock}<3->{
\alert{if} (a < b) \{
  result = a;   // "true" branch
\} \alert{else} \{
  result = b;   // "false" branch
\}}\end{codeblock}

    \end{column}

    \begin{column}{.45\textwidth}
      \begin{codeblock}<4->{
int i = \ddd;
\alert{if} (i < 0) \{
  i = -i;   // "true" branch
\}}\end{codeblock}

    \end{column}

  \end{columns}

  \item<5-> \textit{condition-expr} can be any expression whose result is of type
    (convertible to) \code{bool}, i.e. either true or false

  \item<6-> \textit{statement} can be a block, possibly including multiple
    statements
    \begin{itemize}
    \item In fact, the statement should always be a block
    \end{itemize}
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{\code{bool}}

  Type representing a boolean value
  \begin{itemize}
  \item Set of values: ${false, true}$
  \item Operations: conjunction (\textit{and}), disjunction (\textit{or}),
    negation (\textit{not}), \ldots
  \item Size: typically $1$ byte
  \item Representation: like the \code{int}s \code{0} and \code{1}
  \item Literals: \code{false} and \code{true}

    \begin{codeblock}<2->{
\uncover<2->{bool b = true;}
\uncover<3->{b \tikzref{aref}= i =\tikzref{eref}= j;}
\uncover<6->{bool b2 = i !\tikzref{neref}= 1234;}
\uncover<7->{bool b3 = b2 \alert<7>{\&\&} i < j;    // and
bool b4 = i < j \alert<7>{||} i < k; // or
bool b5 = \alert<7>{!}\alert<8>{(}i == j\alert<8>{)};      // not}}\end{codeblock}

  \item<8-> Note the use of parenthesis in \code{!(i == j)} to have the right
    precedence of application of operators
  \end{itemize}

\uncover<4->{
  \begin{tikzpicture}[remember picture,overlay]
    \uncover<4-5>{
      \node[draw=red,line width=1pt,opacity=.7,rounded corners, minimum width=1.5ex] at ([xshift=.5ex]aref) (abox){};
      \node[below=of abox,draw=red,line width=1pt,opacity=.7,rounded corners] {assignment} edge[->,line width=1pt,red,opacity=.7] (abox);
    }
    \uncover<5>{
      \node[draw=red,line width=1pt,opacity=.7,rounded corners,minimum width=3ex] at (eref) (ebox){};
      \node[below right=of ebox.south east,draw=red,line width=1pt,opacity=.7,rounded corners] {equality} edge[->,line width=1pt,red,opacity=.7] (ebox);
    }
    \uncover<6>{
      \node[draw=red,line width=1pt,opacity=.7,rounded corners,minimum width=3ex] at (neref) (nebox){};
      \node[below=of nebox,draw=red,line width=1pt,opacity=.7,rounded corners] {inequality} edge[->,line width=1pt,red,opacity=.7] (nebox);
    }
  \end{tikzpicture}
}

\end{frame}

\begin{frame}{Logical operations}

  \begin{description}[<+->]

  \item[and] Both operands are true
    \vskip .5em
    {\scriptsize\begin{tabular}{ c c | c }
      op1 & op2 & op1 \textbf{\&\&} op2 \\
      \hline
      \code{false} & \code{false} & \code{false} \\
      \code{false} & \code{true} & \code{false} \\
      \code{true} & \code{false} & \code{false} \\
      \code{true} & \code{true} & \code{true} \\
    \end{tabular}}
    \vskip .5em

    \code{op2} is evaluated only if \code{op1} is \code{true}

  \item[or] At least one operand is true
    \vskip .5em

    {\scriptsize\begin{tabular}{ c c | c }
      op1 & op2 & op1 \textbf{||} op2 \\
      \hline
      \code{false} & \code{false} & \code{false} \\
      \code{false} & \code{true} & \code{true} \\
      \code{true} & \code{false} & \code{true} \\
      \code{true} & \code{true} & \code{true} \\
    \end{tabular}}
    \vskip .5em

    \code{op2} is evaluated only if \code{op1} is \code{false}

  \item[not] Operand's negation (or logical complement)
    \vskip .5em

    {\scriptsize\begin{tabular}{ c | c }
      op & \textbf{!}op \\
      \hline
      \code{false} & \code{true} \\
      \code{true}  & \code{false} \\
    \end{tabular}}
    \vskip .5em

  \end{description}

\end{frame}

\begin{frame}{Scope}

  The scope of a name appearing in a program is the, possibly
  discontiguous, portion of source code where that name is valid

  \begin{itemize}
  \item block scope
  \item function scope
  \item class scope
  \item namespace scope (including the global one)
  \item \ldots
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Block scope}

  \begin{itemize}[<+->]
  \item The scope of a name declared in a block starts at the point of
    declaration and ends at the \code{\}}

    \begin{codeblock}
\{
  \ddd
  int num;         // scope of num begins here
  std::cin >{}> num; // ok
\}                  // scope of num ends here
std::cout <{}< num;  // error\end{codeblock}

  \item<2-> The scope of a variable should be as small as possible
    \begin{itemize}
    \item Declare a variable only when it's needed
    \item If possible/meaningful, initialize it
    \end{itemize}
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Example: is a number even?}

  A program that reads a number from input and tells if it's even

  \begin{columns}[T]
    \begin{column}{.6\textwidth}
  \uncover<2->{
    \begin{tikzpicture}
      [auto,
      startstop/.style = {rectangle, rounded corners=5pt, draw=black, thick, node font=\scriptsize,
        text width=3em, align=flush center},
      inout/.style     = {trapezium, trapezium left angle=60,trapezium right angle=120, thick, draw=green, fill=green!20,
        text width=4em, align=flush center, node font=\scriptsize},
      block/.style     = {rectangle, draw=blue, thick, fill=blue!20,align=center, rounded corners=2pt,
        text width=5em, align=flush center, node font=\scriptsize},
      decision/.style  = {diamond, aspect=1.5, draw=red, thick, fill=red!20, text width=4em, align=flush center, inner sep=1pt, node font=\scriptsize},
      line/.style      = {draw, thick, -latex, shorten >=2pt}]
      \matrix [column sep=0mm,row sep=4mm,ampersand replacement=\&]
      {
        % row
        \& \node [startstop] (start) {start}; \\
        % row
        \& \node [inout] (in) {read num}; \\
        % row
        \& \node [block,text width=7em] (mod) {r $\leftarrow$ num \textit{mod} 2}; \\
        % row
        \& \node [decision] (iszero) {r == 0}; \\[-4mm]
        % row
        \node [block,text width=6em] (even) {result $\leftarrow$ true}; \&
        \& \node [block,text width=6em] (odd) {result $\leftarrow$ false}; \\
        % row
        \& \coordinate (join); \\
        % row
        \& \node [inout,text width=6em] (out) {write result}; \\
        % row
        \& \node [startstop] (stop) {stop}; \\
      };
      \begin{scope}[every path/.style=line]
        \path (start)  -- (in);
        \path (in)     -- (mod);
        \path (mod)    -- (iszero);
        \path (iszero) -| node [near start,above] {\scriptsize{yes}} (even);
        \path (iszero) -| node [near start,above] {\scriptsize{no}} (odd);
        \path[-,shorten >=0pt] (even) |- (join);
        \path[-,shorten >=0pt] (odd)  |- (join);
        \path (join) -- (out);
        \path (out)    -- (stop);
      \end{scope}
    \end{tikzpicture}
  }
    \end{column}

    \begin{column}{.4\textwidth}
      \begin{codeblock}<3->{
#include <iostream>

int main()
\{
\uncover<4->{\alert<4>{  int num;
  std::cin >{}> num;}}
\uncover<5->{\alert<5>{  int r = num \% 2;}}
\only<7-10>{\alert<7>{  bool result;}}\only<11->{  bool result \alert<11>{= r == 0};}
\only<6-10>{\alert<6>{  if (r == 0) \{}}
\only<7-10>{\alert<7>{    result = true;}}
\only<6-10>{\alert<6>{  \} else \{}}
\only<7-10>{\alert<7>{    result = false;}}
\only<6-10>{\alert<6>{  \}}}
\only<9>{  // print 0/1}\only<10>{  // print false/true}
\only<8-9>{\alert<8>{  std::cout <{}< result <{}< \bslashn;}}\only<10->{  std::cout <{}< \alert<10>{std::boolalpha}
      <{}< result <{}< \bslashn;}
\}}\end{codeblock}
    \end{column}

  \end{columns}

\end{frame}

\begin{frame}{Exercise: the smallest of three numbers}

  Write a program that reads three numbers from standard input and writes the
  smallest one to standard output

\end{frame}

\begin{frame}[fragile]{Integer square root}

  Write a program that computes the integer square root of a non-negative
  integer number, i.e. the largest integer number whose square is not greater
  than the given number

  \begin{columns}[T]
    \begin{column}{.5\textwidth}
      \uncover<2->{\begin{tikzpicture}
          [auto,
          startstop/.style = {rectangle, rounded corners=5pt, draw=black, thick, node font=\scriptsize,
            text width=3em, align=flush center},
          inout/.style     = {trapezium, trapezium left angle=60,trapezium right angle=120, thick, draw=green, fill=green!20,
            text width=4em, align=flush center, node font=\scriptsize},
          block/.style     = {rectangle, draw=blue, thick, fill=blue!20,align=center, rounded corners=2pt,
            text width=5em, align=flush center, node font=\scriptsize},
          decision/.style  = {diamond, aspect=1.5, draw=red, thick, fill=red!20, text width=4em, align=flush center, inner sep=1pt, node font=\scriptsize},
          line/.style      = {draw, thick, -Classical TikZ Rightarrow, shorten >=1pt}]
          \matrix [column sep=4mm,row sep=3mm,ampersand replacement=\&]
          {
            % row
            \& \node [startstop] (start) {start}; \\
            % row
            \& \node [inout] (in) {read $n$}; \\
            % row
            \& \node [block] (initi) {$i \gets 1$}; \\[-1mm]
            % row
            \& \coordinate (beforecond1); \\
            % row
            \node [block] (inc) {$i \gets i + 1$}; \& \node [decision] (cond1) {$i \times i < n$}; \\
            % row
            \node [block] (dec) {$i \gets i - 1$};
            \& \node [decision] (cond2) {$i \times i > n$}; \\[-1mm]
            % row
            \& \coordinate (aftercond2); \\
            % row
            \& \node [inout] (out) {write $i$}; \\
            % row
            \& \node [startstop] (stop) {stop}; \\
          };
          \begin{scope}[every path/.style=line]
            \path (start)  -- (in);
            \path (in)     -- (initi);
            \path (initi)  -- (cond1);
            \path (cond1)  -- node {\scriptsize{no}} (cond2);
            \path (cond1)  -- node {\scriptsize{yes}} (inc);
            \path (inc)    |- (beforecond1);
            \path (cond2)  -- node [near start] {\scriptsize{no}} (out);
            \path (cond2)  -- node {\scriptsize{yes}} (dec);
            \path (dec)    |- (aftercond2);
            \path (out)    -- (stop);
          \end{scope}
        \end{tikzpicture}}

    \end{column}

    \begin{column}{.5\textwidth}
      \begin{codeblock}<3->{
#include <iostream>

int main()
\{
  int n;
  std::cin >> n;
  int i = 1;
  while (i * i < n) \{
    ++i;   // equivalent to i = i + 1
  \}
  if (i * i > n) \{
    --i;   // equivalent to i = i - 1
  \}
  std::cout << i << \bslashn;
\}}\end{codeblock}
    \end{column}

  \end{columns}

\end{frame}

\begin{frame}[fragile]{\code{while} loop}

  \begin{center}
    \code{while (} \textit{condition-expr} \code{)} \textit{statement}
  \end{center}

  \pause

  \begin{itemize}[<+->]
  \item Execute repeatedly \textit{statement} until \textit{condition-expr}
    becomes false
  \item \textit{condition-expr} is evaluated at the beginning of each iteration
    \begin{itemize}
    \item If \textit{condition-expr} is already \code{false} at the beginning,
      \textit{statement} is never executed
    \end{itemize}
  \item \textit{statement} can be any statement, including of course a block
  \item \textit{statement} should modify something so that the evaluation of
    \textit{condition-expr} may change
    \begin{itemize}[<.->]
    \item Otherwise the loop may never terminate
    \end{itemize}
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Sum of the first N numbers}
  Write a program that reads a non-negative integer number N from standard
  input, computes the sum of the first N numbers and writes the result to
  standard output

  \begin{columns}[T]

    \begin{column}{.5\textwidth}
      \begin{codeblock}<2->{
#include <iostream>

int main()
\{
  int n;
  std::cin >{}> n;
  int sum = 0;
  \alert<3->{int i = 1;}
  while (\alert<3->{i <= n}) \{
    sum += i;   // sum = sum + i
    \alert<3->{++i};
  \}
  std::cout <{}< sum <{}< \bslashn;
\}}\end{codeblock}

    \end{column}

    \begin{column}{.5\textwidth}
      \begin{codeblock}<4->{
#include <iostream>

int main()
\{
  int n;
  std::cin >{}> n;
  int sum = 0;

  \textbf<4>{for} (\alert<4>{int i = 1}; \alert<4>{i <= n}; \alert<4>{++i}) \{
    sum += i;

  \}
  std::cout <{}< sum <{}< \bslashn;
\}}\end{codeblock}
    \end{column}

  \end{columns}
\end{frame}

\begin{frame}[fragile]{\code{for} loop}

  \code{for (} \textit{init-statement} \opt{\textit{condition-expr}} \code{;}
  \opt{\textit{expression}} \code{)} \textit{statement}

  \pause

  \begin{itemize}[<+->]
  \item Execute \textit{init-statement}, which may be a single \code{;}
    \begin{itemize}
    \item If \textit{init-statement} contains declarations (e.g. the \code{i}
      variable in the previous example), the scope of the declared names is
      the loop
    \end{itemize}
  \item Execute repeatedly \textit{statement} until \textit{condition-expr} becomes false
  \item \textit{condition-expr} is evaluated at the beginning of each iteration
    \begin{itemize}
    \item If \textit{condition-expr} is already false at the beginning,
      \textit{statement} is never executed
    \item But \textit{init-statement} is always executed
    \end{itemize}
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{\code{for} loop \insertcontinuationtext}

  \code{for (} \textit{init-statement} \opt{\textit{condition-expr}} \code{;}
  \opt{\textit{expression}} \code{)} \textit{statement}

  \pause

  \begin{itemize}[<+->]
  \item \textit{expression} is evaluated at the end of each iteration
  \item \textit{statement} and/or \textit{expression} should modify something so
    that the evaluation of \textit{condition-expr} may change
    \begin{itemize}[<.->]
    \item Otherwise the loop may never terminate
    \end{itemize}
  \item A \code{for} loop can always be transformed into a \code{while} loop and
    viceversa
    \begin{itemize}
    \item Prefer a \code{for} loop when there is an obvious loop variable
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Integer square root with a \code{for} loop}

  Write a program that computes the integer square root of a non-negative
  integer number, i.e. the largest integer number whose square is not greater
  than the given number

  \begin{columns}[T]
    \begin{column}{.35\textwidth}
      \begin{codeblock}
#include <iostream>

int main()
\{
  int n;
  std::cin >{}> n;
  int i = 1;
  while (i * i < n) \{
    ++i;
  \}
  if (i * i > n) \{
    --i;
  \}
  std::cout << i << \bslashn;
\}\end{codeblock}
    \end{column}

    \begin{column}{.65\textwidth}
      \begin{codeblock}<2->{
#include <iostream>

int main()
\{
  int n;
  std::cin >{}> n;
  \uncover<4->{int i = 1;}
  for (\alt<-3>{int i = 1}{ }; i * i < n; ++i) \alt<-5>{\{}{\alert<6>{;}}
    \only<-4>{;}
  \only<-5>{\}}
  if (\alert<3>{i} * \alert<3>{i} > n) \{\uncover<3>{ // \alert{error: undeclared variable}}
    --\alert<3>{i};
  \}
  std::cout << i << \bslashn;
\}}\end{codeblock}
    \end{column}

  \end{columns}

  \uncover<7>{}

\end{frame}

\begin{frame}{Exercise: the smallest of N numbers}

  Write a program that reads an arbitrary sequence of numbers from standard
  input and writes the smallest one to standard output

  Hint 1: press Ctrl-D to tell the program there is nothing more to read from
  standard input

  Hint 2: the expression \code{std::cin.good()} tells if it's still possible to
  read something from \code{std::cin}
\end{frame}

\begin{frame}[fragile]{\code{double}}

  Type representing a floating-point number

  \begin{itemize}
  \item<2-> Set of values: subset of $\mathbb{R}$
  \item<3-> Operations: addition, subtraction, multiplication, division, comparisons, \ldots
  \item<4-> Representation: \href{https://en.wikipedia.org/wiki/IEEE_754}{IEEE 754}
  \item<5-> 64 bits, smallest values $\approx\pm10^{-308}$, largest values $\approx\pm10^{308}$
  \item<6-> Precision is about 16 decimal digits
  \item<6-> Literals in the form \opt{\textit{sign}} \textit{significand} \opt{\textit{exponent}}
    \begin{itemize}
    \item \code{42.0 1. -1.5 12.34e3 -.34E-3 -1234e-2}
    \item \code{\ddd{}e\textit{n}}/\code{\ddd{}E\textit{n}} means $\times 10^{n}$
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{\code{float}}

  Type representing a floating-point number

  \begin{itemize}
  \item<2-> Set of values: subset of $\mathbb{R}$
  \item<3-> Operations: addition, subtraction, multiplication, division, comparisons, \ldots
  \item<4-> Representation: \href{https://en.wikipedia.org/wiki/IEEE_754}{IEEE 754}
  \item<5-> 32 bits, smallest values $\approx\pm10^{-38}$, largest values $\approx\pm10^{38}$
  \item<6-> Precision is about 7 decimal digits
  \item<6-> Literals in the form \opt{\textit{sign}} \textit{significand} \opt{\textit{exponent}} \code{F}
    \begin{itemize}
    \item \code{42.0f 1.F -1.5f 12.34e3F -.34E-3f -1234e-2F}
    \item Same as double but with an \code{f} or \code{F} suffix
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Handle floating-point numbers with care}

  \begin{itemize}
  \item<1-> Floating-point numbers are \textbf{not} real numbers
    \begin{itemize}
    \item Finite representation $\implies$ there is a previous and a next
    \end{itemize}
  \item<2-> When managing floating-point numbers one should take into account
    rounding errors and inexact representations
    \begin{codeblock}<3->{
float x = 1\textquotesingle000\textquotesingle000\textquotesingle000;
\uncover<4->{std::cout << std::setprecision(10)
  << x - 32 << \upquote{ } << x << \upquote{ } << x + 32}\uncover<5->{ // 1000000000 1000000000 1000000000}
\uncover<6->{  << x + 32 - x << \upquote{ } << x - x + 32;}\uncover<7->{    // 0 32}}\end{codeblock}
  \item<8-> Floating-point math in general is not associative
  \item<9-> When comparing floating-point numbers avoid the use of equality
  \item<10-> See \href{https://cr.yp.to/2005-590/goldberg.pdf}{What Every
      Computer Scientist Should Know About Floating Point Arithmetic}
 \end{itemize}

\end{frame}

\begin{frame}[fragile]{Standard mathematical functions}

  The \href{https://en.cppreference.com/w/cpp/header/cmath}{\code{cmath}} header
  includes many ready-to-use mathematical functions
  \begin{itemize}
  \item Exponential
  \item Power
  \item Trigonometric
  \item Interpolation
  \item Hyperbolic
  \item Floating-point manipulation, classification and comparison
  \item \ldots
  \end{itemize}

  \begin{codeblock}<2->{
#include <cmath>
\ddd
double x = \ddd;
std::sqrt(x);
std::pow(x, .5);
std::sin(x);
std::log(x);
std::abs(x);}\end{codeblock}
\end{frame}

\begin{frame}[fragile]{Type conversions}

    \begin{itemize}
    \item A value of type \code{T1} may be converted \textbf{implicitly} to a
      value of type \code{T2} in order to match the expected type in a certain
      situation
      \begin{codeblock}<2->{
1 + 2.3}\end{codeblock}
      \begin{itemize}[<3->]
      \item between numbers and bool
      \item between signed and unsigned numbers
      \item between numbers of different size
      \item between integral and floating-point numbers
      \item \ldots
      \end{itemize}

    \item<4-> Conversions sometimes are surprising
    \item<5-> Conversions can be explicit using \code{static_cast}
      \begin{codeblock}<.->{
1 + static_cast<int>(2.3)}\end{codeblock}
    \item<6-> Mechanims exist to define implicit and explicit conversions
      involving user-defined types

    \end{itemize}

\end{frame}

\begin{frame}[fragile]{\code{const}-safety}

  \begin{itemize}
  \item Data qualified as \code{const} is logically immutable
  \item Data that is meant to be immutable should be \code{const}
  \end{itemize}

  \begin{codeblock}<2->{
int \alert{const} x = 1\textquotesingle000\textquotesingle000\textquotesingle000; // or const int
\uncover<3->{std::cout << x + 32;    // ok, read-only}
\uncover<4->{x += 32;                // error, trying to modify}
\uncover<5->{int const y;            // error, not initialized and not modifiable later}
}\end{codeblock}

\begin{codeblock}<6->{
std::string \alert{const} message = "Hello";
\uncover<7->{std::cout << message + " Francesco";      // ok, read-only}
\uncover<8->{message += " Francesco";                  // error, trying to modify}
\uncover<9->{std::string const empty_message;          // ok! empty string}}\end{codeblock}

  \begin{itemize}[<10->]
  \item Primitive types (e.g. \code{int}) and user-defined types such as
    \code{std::string}) behave differently with respect to \textit{default
      initialization}, i.e. without an explicit initial value
    \begin{itemize}
    \item User-defined types can define what default initialization means
    \item For \code{std::string} it means ``empty string''
    \item More later
    \end{itemize}
  \end{itemize}

\end{frame}

\begin{frame}{Functions}

  \begin{itemize}[<+->]
  \item A function abstracts away a piece of code that performs a well-defined
    task behind a well-defined interface
  \item A function associates a block of statements with
    \begin{itemize}
    \item a name
    \item a list of zero or more parameters
    \end{itemize}
  \item A function may return a result
  \end{itemize}

  \begin{itemize}[<+->]
  \item Let's consider the code that computes the integer square root
    \begin{itemize}
    \item Let's give it a name $\rightarrow$ \code{isqrt}
    \item We pass \code{isqrt} a number $\rightarrow$ the list of parameters has
      only one item of type \code{int}
    \item \code{isqrt} computes a value that we want back $\rightarrow$ the
      function returns a value of type \code{int}
    \end{itemize}
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{The \code{isqrt} function}

  \begin{columns}[T]
    \begin{column}{.5\textwidth}
      \begin{codeblock}
#include <iostream>

int main()
\{
  int n;
  std::cin >{}> n;
  int i = 1;
  while (i * i < n) \{
    ++i;
  \}
  if (i * i > n) \{
    --i;
  \}
  std::cout << i << \bslashn;
\}\end{codeblock}

      \vskip .5cm

      \uncover<2>{Names on the two sides of the call are independent}
    \end{column}

    \begin{column}{.5\textwidth}
      \begin{codeblock}
#include <iostream>

int isqrt(int \alert<2>{n})  \only<1>{// \alert{function definition}}
\{
  int i = 1;
  while (i * i < n) \{
    ++i;
  \}
  if (i * i > n) \{
    --i;
  \}
  return \alert<2>{i};      \only<1>{// \alert{return statement}}
\}

int main()
\{
  int \alt<1>{n}{\alert<2>{num}};
  std::cin >{}> \alt<1>{n}{\alert<2>{num}};
  int \alt<1>{i}{\alert<2>{result}} = isqrt(\alt<1>{n}{\alert<2>{num}});  \only<1>{// \alert{function call}}
  std::cout <{}< \alt<1>{i}{\alert<2>{result}} <{}< \bslashn;
\}\end{codeblock}
    \end{column}

  \end{columns}

\end{frame}

\begin{frame}{Functions \insertcontinuationtext}

  \begin{itemize}
  \item<1-> A function needs to be declared/defined before its use

    \textit{return-type} \textit{function-name} \code{(} \textit{parameter-list} \code{);}

    \textit{return-type} \textit{function-name} \code{(} \textit{parameter-list} \code{) \{ \ddd \}}

    \visible<2->{

      \code{int isqrt(int);}

      \code{int count_words(std::string s) \{ \ddd \}}

      \code{double pow(double base, double exponent);}

      \code{void print(std::string);}

      \code{int generate_random_number();}
    }

  \item<3-> Each parameter in the parameter list is of the form

    \textit{type \opt{name}}

    \textit{type} is mandatory, \textit{name} is optional

  \item<4-> Parameters are separated by commas

  \item<5-> The parameter list can be empty, i.e. \code{()}

  \item<6-> The \code{return} statement returns the result (and the control) to
    the calling function

  \item<7-> If the function returns nothing, the return type is \code{void}
  \end{itemize}

\end{frame}

\begin{frame}{Functions \insertcontinuationtext}

  \begin{itemize}

  \item<1-> A function has only one entry point, but it may have multiple exit
    points, i.e. there can be multiple \code{return} statements

    \begin{itemize}
    \item For a function returning a non-\code{void} type

      \code{return} \textit{expression}\code{;}

      The result of \textit{expression} must be convertible to the return type

    \item For a function returning \code{void}

      \code{return;}

      In this case the \code{return} is optional (at the end of the function)

    \end{itemize}

  \end{itemize}
\end{frame}

\begin{frame}{Functions \insertcontinuationtext}

  \begin{itemize}
  \item<1-> Calling/invoking a function is a type of expression of the form $F(E_1,
    E_2, \ldots, E_N)$
    \begin{itemize}
    \item $F$ is an expression that identifies a function, typically its name
    \item Each $E_i$ is an expression, whose value is used to initialize the
      corresponding parameter (i.e. in the same position) in the function
      declaration
    \end{itemize}

    \visible<2->{
      \code{int s = isqrt(24);}

      \code{std::cout << count_words("Hello, " + name);}

      \code{print(std::to_string(pow(isqrt(24), 2)));}
    }

  \item<3-> A function can call other functions
  \item<4-> A function should not be too long; if it is, try to break it into
    multiple parts, each implemented as a function
  \item<5-> A function can call itself, directly or indirectly
    \begin{itemize}
    \item This is called \textit{recursion}
    \item Often an elegant alternative to a loop
    \item Not easy to master, don't abuse
    \end{itemize}
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{The \code{main} function}
  \begin{itemize}
  \item The \code{main} (special) function is the entry point of a program
  \item It can have two forms
    \begin{itemize}
    \item \code{int main() \{\ddd\}}
    \item \ldots (see later)
    \end{itemize}
  \item If there is no \code{return} statement, an implicit \code{return 0;} is assumed
    \begin{itemize}
    \item $0$ means success, different from $0$ means failure
    \item Or use \code{EXIT_SUCCESS} and \code{EXIT_FAILURE} from \code{<cstdlib>}
    \item The exit value is available to the shell via the \code{\$?} variable
    \end{itemize}
  \end{itemize}

  \begin{codeblock}<2->{
#include <cstdlib>

int main()
\{
  int n;
  std::cin >{}> n;
  if (std::cin.fail() || n < 0) \{
    std::cerr << "Invalid number\bslash{}n";
    return EXIT_FAILURE;
  \}
  \ddd
\}}\end{codeblock}

\end{frame}

\begin{frame}{Exercises}
  \begin{itemize}
  \item Write a function \code{pow} that takes two \code{int}s and computes and
    returns the value of the first (the base) raised to the power of the second
    (the exponent)
  \item Write a function \code{gcd} that takes two \code{int}s and computes the
    Gratest Common Denominator using the
    \href{https://en.wikipedia.org/wiki/Euclidean_algorithm}{Euclid's algorithm}
  \item Write a function \code{lcm} that takes two \code{int}s and computes the
    Least Common Multiple
  \item Write a function \code{is\_prime} that takes an \code{int} and tells if
    it's a prime number
  \item More on \href{https://edabit.com/}{edabit}, \href{https://leetcode.com/}{leetcode}, \ldots
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{How do we know the code we write is correct?}

  \begin{itemize}[<+->]
  \item Correctness is the result of the application of multiple good practices
    to the software developmente process
  \item One of the most effective techniques is \textbf{testing}
    \begin{itemize}
    \item Execute the code with reasonable and unreasonable input and see if it
      behaves according to the expectations
    \item The purpose of testing is to (try to) \alert{break} the code
    \end{itemize}
  \item Here we focus on a form of testing called \textit{unit testing}, where
    the units (of code) under test are, for example, functions
  \item There are many tools/frameworks to do unit testing (Google Test, Catch,
    Doctest, Boost.Test, \ldots)
  \item Let's use \href{https://github.com/onqtam/doctest}{Doctest}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{How to use Doctest}

  \begin{itemize}
  \item On \href{https://godbolt.org/}{godbolt} it's available selecting it
    under ``Libraries''
  \item Otherwise download locally a single
    \href{https://raw.githubusercontent.com/onqtam/doctest/master/doctest/doctest.h}{\textit{header
        file}} into the directory containing your code, e.g. using \code{wget}
    or \code{curl}
  \item At the top of your \Cpp{} file add the lines
    \begin{codeblock}
#define DOCTEST\_CONFIG\_IMPLEMENT\_WITH\_MAIN
#include "doctest.h"\end{codeblock}
  \item Don't add \code{main} into your file
  \item After the code of the function(s) you have written, add lines like the
    following:
    \begin{codeblock}
TEST_CASE("Testing isqrt") \{
  CHECK(isqrt(0) == 0);
  CHECK(isqrt(9) == 3);
  CHECK(isqrt(10) == 3);
  CHECK(isqrt(-1) == 0);
  \ddd
\}\end{codeblock}

  \end{itemize}

\end{frame}

\begin{frame}{Memory layout of a process}

  \begin{itemize}
  \item A process is a running program
  \item When a program is started the operating system brings the contents of
    the corresponding file into memory according to well-defined conventions
  \end{itemize}

  \begin{columns}
    \begin{column}{.7\textwidth}
      \begin{itemize}
        \item[]
      \begin{itemize}
      \item Stack
        \begin{itemize}
        \item function local variables
        \item function call bookkeeping
        \end{itemize}
      \item Heap
        \begin{itemize}
        \item dynamic allocation
        \end{itemize}
      \item Global data
        \begin{itemize}
        \item literals and variables
        \item initialized and uninitialized (set to 0)
        \end{itemize}
      \item Program instructions
      \end{itemize}
    \end{itemize}
  \end{column}

    \begin{column}{.3\textwidth}
      \centering\includegraphics[height=.5\textheight]{images/process-memory-layout}
    \end{column}
  \end{columns}

\end{frame}

\begin{frame}[fragile]{Functions and the stack}

  \begin{columns}
    \begin{column}{.5\textwidth}
      \begin{codeblock}
\alert<4>{int isqrt(int n)
\{
  int i} \alert<6>{= 1};
  \alert<7>{while (i * i < n) \{
    ++i;
  \}
  if (i * i > n) \{
    --i;
  \}}
  \alert<8>{return i;}
\alert<4>{\}}

\alert<2>{int main()
\{
  int num};
  \alert<3>{std::cin >{}> num;}
  \alert<2>{int result} \alert<8>{=} \alert<4>{isqrt(}\alert<5>{num}\alert<4>{)};
  std::cout <{}< result <{}< \bslashn;
\alert<2>{\}}\end{codeblock}

    \end{column}

    \begin{column}{.4\textwidth}
      \begin{tikzpicture}[
        mem/.style={
          minimum width=2cm,
          inner sep=0pt,
          outer sep=0pt,
          draw=black
        },
        frame/.style={
          minimum width=2cm,
          inner sep=0pt,
          outer sep=0pt,
          draw=black,
          thick,
          fill=green!50!white
        },
        var/.style={
          node font=\ttfamily\scriptsize,
          minimum height=.5cm,
          minimum width=2cm,
          draw=black,
          fill=green!30!white,
          inner sep=0pt,
          outer sep=0pt
        },
        anchor=south west]
        \visible<1->{
          \node at (0,0) [
          mem,
          minimum height=7cm,
          label={90:Stack}] {};
        }
        \visible<2-9>{
          \node (main) at (0,4) [
            frame,
            minimum height=2cm,
            label={[yshift=.9cm]0:\scriptsize\tt main}
          ] {};
          \node (result) [
            var,
            above=3ex of main.south,
            label={180:\scriptsize\tt result}
          ] {\only<8->{2}};
          \node (num) [
            var,
            above=0pt of result,
            label={180:\scriptsize\tt num}
          ] {\only<3->{5}};
        }
        \visible<4-8>{
          \node (isqrt) [
            frame,
            below=0pt of main,
            minimum height=2cm,
            label={[yshift=.9cm]0:\scriptsize\tt isqrt}
          ] {};
          \node (i) [
            var,
            above=3ex of isqrt.south,
            label={180:\scriptsize\tt i}
          ] {\only<6>{1}\only<7->{2}};
          \node (n) [
            var,
            above=0pt of i,
            label={180:\scriptsize\tt n}
          ] {\only<5->{5}};
        }
        \visible<2-3,9>{
          \node (main rsp) at ([xshift=-2cm]main.south west) {\scriptsize\tt \%rsp};
          \draw[->] (main rsp) -- +(1.5cm,0);
        }
        \visible<4-8>{
          \node (isqrt rsp) at ([xshift=-2cm]isqrt.south west) {\scriptsize\tt \%rsp};
          \draw[->] (isqrt rsp) -- +(1.5cm,0);
        }
      \end{tikzpicture}
    \end{column}

  \end{columns}

  \uncover<10>{}

\end{frame}

\begin{frame}{Pass by-value, return by-value}

  Given a function

  % \tikzref doesn't work inside \code nor inside \texttt; to be investigated

  \begin{equation*}
    \code{R F(T$_1$ p}\tikzref{p1}\code{$_1$, \ddd, T$_n$ p}\tikzref{pn}\code{$_n$) \{ \ddd{} return E}\tikzref{er}\code{$_R$; \} }
  \end{equation*}

  and a function call

  \begin{equation*}
    \code{R r}\tikzref{r}\code{ = F(E}\tikzref{e1}\code{$_1$, \ddd, E}\tikzref{en}\code{$_n$);}
  \end{equation*}

  \begin{itemize}
  \item<2-> Each \code{p$_i$} is initialized as a \alert{copy} of the value of
    expression \code{E$_i$}
    \begin{itemize}
    \item If \code{E$_i$} is just a variable, changing \code{p$_i$} inside the
      function doesn't change the variable
    \end{itemize}
  \item<3-> \code{r} is initialized as a \alert{copy} of the value of expression
    \code{E$_R$}
  \end{itemize}

  \visible<2->{
    \tikz[remember picture, overlay] \draw[-Stealth,blue,line width=1pt] ([yshift=1ex] e1) -- ([yshift=-1ex]p1);
    \tikz[remember picture, overlay] \draw[-Stealth,blue,line width=1pt] ([yshift=1ex] en) -- ([yshift=-1ex]pn);
  }
  \visible<3->{
    \tikz[remember picture, overlay] \draw[-Stealth,brown,line width=1pt] ([yshift=-1ex] er) -- ([yshift=1ex]r);
  }

\end{frame}

\begin{frame}{Stack frame}

  \begin{itemize}[<+->]
  \item A piece of memory allocated and dedicated to the execution of a function
  \item It contains local variables (including function parameters), return
    address, saved registers, \ldots
  \item Managed in a Last-In, First-Out (LIFO) way
  \item The size of the stack frame is computed by the compiler
  \item There is a special register (the stack pointer register, \code{\%rsp})
    that indicates the frame of the currently running function
  \item At runtime the allocation/deallocation of a frame consists simply in
    subtracting/adding that frame size to the stack pointer register
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Passing by value may be expensive}

  Let's consider a function that counts the number of words in a string

  \begin{columns}
    \begin{column}{.5\textwidth}

      \begin{codeblock}
int count_words(std::string \alert<5>{s})
\{
  int count = 0;
  \ddd
  return count;
\}

\alert<2>{int main()
\{
  std::string text} \alert<3>{= \ddd};
  \alert<2>{int const res} = \alert<4>{count_words(}\alert<5>{text}\alert<4>{)};
  std::cout <{}< res <{}< \bslashn;
\alert<2>{\}}\end{codeblock}

      \begin{itemize}
      \item<5-> \code{s} is a \textbf{copy} of \code{text}
      \item<6-> I'm slightly cheating: not all string memory goes on the stack
      \end{itemize}

    \end{column}

    \begin{column}{.4\textwidth}

      \begin{tikzpicture}[
        mem/.style={
          minimum width=2cm,
          inner sep=0pt,
          outer sep=0pt,
          draw=black
        },
        frame/.style={
          minimum width=2cm,
          inner sep=0pt,
          outer sep=0pt,
          draw=black,
          thick,
          fill=green!50!white
        },
        var/.style={
          node font=\ttfamily\scriptsize,
          minimum height=.5cm,
          minimum width=2cm,
          draw=black,
          fill=green!30!white,
          inner sep=0pt,
          outer sep=0pt
        },
        anchor=south west
        ]
        \node at (0,0) [
          mem,
          minimum height=6cm
        ] {};
        \visible<2->{
          \node (main) at (0,3) [
            frame,
            minimum height=2.5cm,
            label={[yshift=1.1cm]0:\scriptsize\tt main}
          ] {};
          \node (result) [
            var,
            above=3ex of main.south,
            label={180:\scriptsize\tt res}
          ] {};
          \node (text) [
            var,
            minimum height=1cm,
            text width=2cm,
            align=center,
            above=0pt of result,
            label={180:\scriptsize\tt text}
          ] {\only<3->{\tiny\textit{Nel mezzo del cammin di nostra vita\ldots}}};
        }
        \visible<4->{
          \node (countwords) [
            frame,
            below=0pt of main,
            minimum height=2.5cm,
            label={[yshift=1.1cm]0:\scriptsize\tt count_words}
          ] {};
          \node (count) [
            var,
            above=3ex of countwords.south,
            label={180:\scriptsize\tt count}
          ] {};
          \node (s) [
            var,
            minimum height=1cm,
            text width=2cm,
            align=center,
            above=0pt of count,
            label={180:\scriptsize\tt s}
          ] {\only<5->{\tiny\textit{Nel mezzo del cammin di nostra vita\ldots}}};
        }
      \end{tikzpicture}
    \end{column}

  \end{columns}
\end{frame}

\begin{frame}[fragile]{References}

  \begin{itemize}
  \item A variable declared as a \alert{reference} of a type \code{T} is another
    name (an \textit{alias}) for an existing object of type \code{T}
  \end{itemize}

  \begin{tikzpicture}[
      mem/.style={
        node font=\ttfamily\scriptsize,
        minimum height=.5cm,
      },
      location/.style={
        mem,
        draw=black!50,
        minimum width=2cm,
        fill=green!20!white,
      },
      every node/.style={
        mem,
      },
      anchor=south west,
      node distance=0,
    ]

    \visible<2->{
      \node (memory) at (0,0) [mem, draw=black!50, minimum width=\textwidth] {};

      \node (i) at (2,0) [
        location,
        "i" below,
        "\alert<3>{ri}" {visible on=<3->,yshift=-0.3cm,below}
      ] {\only<-4>{12}\only<5-6>{34}\only<7->{56}};

      \node (j) at (7,0) [
        location,
        "j" below
      ] {56};
    }

  \end{tikzpicture}

  \begin{codeblock}<2->{
int i = 12;
int j = 56;
\uncover<3->{int\alert<3>{\&} ri = i;         // reference declarator}
\uncover<4->{ri == 12;            // true}
\uncover<5->{ri = 34;}
\uncover<6->{ri == 34 \&\& i == 34; // true}
\uncover<7->{ri = j;}
\uncover<8->{ri == 56 \&\& i == 56; // true}
\uncover<9->{int\& r;              // error}}\end{codeblock}

  \begin{itemize}
  \item<10-> A reference must be initialized to refer to a valid object
  \item<10-> A reference cannot \textit{rebind} (be re-associated) to another
    object
  \item<11-> For a given type \code{T}, \code{T\&} is a \textit{compound} type,
    distinct from \code{T}
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Passing by reference}

  \begin{columns}
    \begin{column}{.5\textwidth}

      \begin{codeblock}
int count_words(std::string\alert<1->{\&} s)
\{
  \alert<5>{int count = 0;}
  \alert<6>{\ddd}
  \alert<7>{return count;}
\}

\alert<2>{int main()
\{
  std::string text} \alert<3>{= \ddd};
  \alert<2>{int const res} \alert<7>{=} \alert<4>{count_words(text)};
  std::cout <{}< res <{}< \bslashn;
\alert<2>{\}}\end{codeblock}

      \uncover<8>{}
      \uncover<9>{}

      \vskip .5 cm

      \visible<4->{\scriptsize (*) In general it's unspecified if a reference
        occupies storage. Here probably it does (called s$'$)}

    \end{column}

    \begin{column}{.4\textwidth}

      \begin{tikzpicture}[
        mem/.style={
          minimum width=2cm,
          inner sep=0pt,
          outer sep=0pt,
          draw=black
        },
        frame/.style={
          minimum width=2cm,
          inner sep=0pt,
          outer sep=0pt,
          draw=black,
          thick,
          fill=green!50!white
        },
        var/.style={
          node font=\ttfamily\scriptsize,
          minimum height=.5cm,
          minimum width=2cm,
          draw=black,
          fill=green!30!white,
          inner sep=0pt,
          outer sep=0pt
        },
        anchor=south west
        ]
        \node at (0,0) [
          mem,
          minimum height=6cm
        ] {};
        \visible<2-8>{
          \node (main) at (0,3) [
            frame,
            minimum height=2.5cm,
            label={[yshift=1.1cm]0:\scriptsize\tt main}
          ] {};
          \node (result) [
            var,
            above=3ex of main.south,
            label={180:\scriptsize\tt res}
          ] {\only<7-8>{12345}};
          \node (text) [
            var,
            minimum height=1cm,
            text width=2cm,
            align=center,
            above=0pt of result,
            "\scriptsize\tt text" left,
            "\scriptsize\tt\alert<4-7>{s}" {visible on=<4-7>,xshift=-.8cm,left}
          ] {\only<3->{\tiny\textit{Nel mezzo del cammin di nostra vita\ldots}}};
        }
        \visible<4-7>{
          \node (countwords) [
            frame,
            below=0pt of main,
            minimum height=1.7cm,
            label={[yshift=.5cm]0:\scriptsize\tt count_words}
          ] {};
          \node (count) [
            var,
            above=3ex of countwords.south,
            label={180:\scriptsize\tt count}
          ] {\only<5>{0}\only<6-7>{12345}};
          \node (sref) [
            var,
            above=0pt of count,
            label={180:\scriptsize\tt s$'$}
          ] {(*)};
        }
      \end{tikzpicture}
    \end{column}

  \end{columns}
\end{frame}

\begin{frame}[fragile]{\code{const} and references}

  \begin{codeblock}
std::string name = "Francesco";
\uncover<2->{std::string\alert{\&} rname = name;        // ok, can read/modify name via rname}
\uncover<3->{std::string \alert{const\&} crname = name; // ok, crname is a read-only view of name}\end{codeblock}

  \begin{codeblock}<4->{
std::string \alert{const} name = "Francesco";
\uncover<5->{std::string\alert{\&} rname = name;        // error, could modify name via rname}
\uncover<6->{std::string \alert{const\&} crname = name; // ok, can only read name via rcname}}\end{codeblock}

  \begin{codeblock}<7->{
int count\_words(std::string \alert{const\&} s)
\{
   \ddd
\}}\end{codeblock}
\end{frame}

\begin{frame}[fragile]{How to pass arguments to functions}
  \begin{itemize}
  \item For input parameters
    \begin{itemize}
    \item If the type is primitive, pass by value
      \begin{codeblock}
int isqrt(int n);        // good
int isqrt(int const& n); // bad!\end{codeblock}
    \item Otherwise pass by const reference
      \begin{codeblock}
int count\_words(std::string const\&);\end{codeblock}
    \end{itemize}
  \item For input-output or output parameters, pass by non-const reference
    \begin{codeblock}
void to_lowercase(std::string\& s);
void read_from_cin(int& n);\end{codeblock}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Function overloading}

  \begin{itemize}
  \item Multiple functions can have the same name
  \item But different lists of parameters (number and/or types)
  \item The compiler chooses the function that best matches the arguments in
    the call
    \begin{itemize}
    \item It usually does what is expected, possibly applying appropriate
      implicit conversions, but not always
    \item Compilation error if there is no match or no unique best match
    \end{itemize}
  \item The return type doesn't matter
  \end{itemize}

  \begin{codeblock}
void foo(int);
int  foo(int, char);
bool foo(double);
int  foo(std::string s);

foo(0);             // call foo(int)
foo(0, \upquote{0});        // call foo(int, char);
foo(0.);            // call foo(double)
foo(std::string\{\}); // call foo(std::string)
foo(0L);            // long int, ambiguous, error
foo(\upquote{a});           // call foo(int)
foo("a");           // call foo(std::string)\end{codeblock}

\end{frame}

\begin{frame}[fragile]{Conditional/ternary operator expression}

  \begin{center}
    \textit{expression}$_{condition}$ \code{?} \textit{expression}$_{true}$ \code{:} \textit{expression}$_{false}$
  \end{center}

  \begin{codeblock}
int gcd(int a, int b)
\{
  return (b == 0) \alert{?} a \alert{:} gcd(b, a \% b);
\}\end{codeblock}

  \begin{itemize}
  \item Evaluate \textit{expression}$_{condition}$, whose value is of type
    (convertible to) \code{bool}
  \item If \code{true}, \textit{expression}$_{true}$ is evaluated and the
    resulting value is the value of the whole expression
  \item If \code{false}, \textit{expression}$_{false}$ is evaluated and the
    resulting value is the value of the whole expression
  \end{itemize}

  \begin{itemize}
  \item Similar to an \code{if} statement, but usable (and useful) where only an
    expression is allowed
  \item The types of \textit{expression}$_{true}$ and
    \textit{expression}$_{false}$ are subject to some constraints, but let's
    assume that they have to be the same
  \end{itemize}

\end{frame}

\begin{frame}{\code{break} and \code{continue} for loops}

  \begin{itemize}
  \item<1-> Within a loop block, the \code{break} statement allows to terminate
    the loop
  \item<2-> Within a loop block, the \code{continue} statement allows to jump to
    the end of the current iteration of the loop
  \item<3> The same effect can be obtained with appropriate use of conditionals,
    but the resulting code may be more complicated
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Object initialization with braces}

  \begin{itemize}
  \item An object can be initialized specifying its value between \code{\{\}}

    \begin{codeblock}
int i\{123\};
float f\{123.F\};
std::string s\{"hello"\};\end{codeblock}

  \item Introduced as a \textit{universal} form of initialization that could
    replace all others, but there are situations where it's not usable

  \item Protects against \textit{narrowing}, i.e. loss of information caused by
    implicit conversions

    \begin{codeblock}
double d\{1.\};         // ok, no conversion
float f1\{1.\};         // ok, no information loss
float f2\{d\};          // error
float f3\{9\textquotesingle{}999\textquotesingle{}999\};  // ok, no information loss
float f3\{99\textquotesingle{}999\textquotesingle{}999\}; // error
int i\{1.\};            // error
int g\{d\};             // error\end{codeblock}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{\code{char}}

  Type representing a character

  \begin{itemize}[<+->]
  \item Set of values: letters in the alphabet (lower- and upper-case), digits,
    punctuation marks, some special characters, \ldots
  \item Size: typically 1 byte, but not necessarily
  \item Representation: let's assume the
    \href{https://en.wikipedia.org/wiki/ASCII}{ASCII} encoding
  \item Literals: characters between single quotes
    \begin{itemize}[<.->]
    \item \code{\upquote{a} \upquote{B} \upquote{7} \upquote{,} \upquote{?} \upquote{\#} \upquote{/}}
    \end{itemize}
  \item Some character literals need to be expressed as \code{\bslash}-escaped
    sequences
    \begin{itemize}[<.->]
    \item \code{\upquote{\bslash\textquotesingle} \upquote{\bslash\bslash} \upquote{\bslash{n}} \upquote{\bslash{t}} \upquote{\bslash{0}}}
    \end{itemize}
  \item A \code{char} is an integral type so it supports integral operations
    \begin{itemize}
    \item \code{std::cout <{}< \upquote{9} - \upquote{0}; // 9}
    \item \code{c < \upquote{z};}
    \end{itemize}
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{\textit{range-for} loop}

    \code{for (} \textit{range-declaration} \code{:} \textit{range-expression} \code{)} \textit{statement}

  \begin{itemize}
  \item Simplified form of a \code{for} loop, to iterate on all the elements of
    a \textit{range} (sequence), such as a string of characters
  \item<2-> Execute repeatedly \textit{statement} for all the elements of the range
  \item<3-> \textit{range-declaration} declares a variable of the same type of
    an element of the range
    \begin{itemize}
    \item Can (and should) be a (const) reference
    \end{itemize}
  \item<4-> \textit{range-expression} represents the range to iterate over
  \item<5-> More on ranges later
  \end{itemize}

  \begin{codeblock}
std::string s\{"Hello!"\};
for (char& c : s) \{
  c = std::toupper(c); 
\}

for (int i : \{1, 2, 3, 4, 5\}) \{
  std::cout << i << \upquote{ };
\}\end{codeblock}

\end{frame}

\begin{frame}{Exercises}

  \begin{itemize}
  \item Write a function that takes a \code{char} and returns the corresponding
    lowercase character if it is a letter; the same char otherwise
    \begin{itemize}
    \item e.g. \upquote{A} $\rightarrow$ \upquote{a}, \upquote{a} $\rightarrow$
      \upquote{a}, \upquote{;} $\rightarrow$ \upquote{;}
    \end{itemize}
  \item Write a function that takes two numeric operands of type \code{double}
    and one operator of type \code{char} and returns the result of applying that
    operator to the two operands. For example if the two operands have values
    $2.0$ and $3.0$ respectively and the operator has value \code{\upquote{+}},
    then the function returns a result with value $5.0$. If the operator is
    invalid, the function returns $0$.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Returning a reference}

  \begin{itemize}
  \item A function can return a reference only if the referenced object survives
    the end of the function
    \begin{itemize}
    \item In the caller, the reference would refer to an object that doesn't
      exist anymore
    \end{itemize}
  \item In particular do not return a reference to a function local variable

    \begin{columns}
      \begin{column}{.5\textwidth}
        \begin{codeblock}
// bad
int& add(int a, int b)
\{
  int result = a + b;
  return result;
\}\end{codeblock}
      \end{column}
      \begin{column}{.5\textwidth}
        \begin{codeblock}
int& increment(int& a) // ok
\{
  ++a;
  return a;
\}\end{codeblock}
      \end{column}
    \end{columns}

  \item Useful to compose multiple function calls on the same object
    \begin{codeblock}
std::string s\{\ddd\};
trim_left(trim_right(tolower(s)));\end{codeblock}

  \end{itemize}
  
\end{frame}

\begin{frame}{Data abstraction}
  \begin{itemize}[<+->]
  \item The \Cpp{} language has a strong focus on building lightweight data
    abstractions
    \begin{itemize}
    \item The source code can use terminology and notation close to the problem
      domain, making it more expressive
    \item There is little (if any) overhead in terms of space or time during
      execution
    \end{itemize}
  \item \code{class} and \code{struct} are the primary mechanism to define new
    compound types on top of fundamental types
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Data structure}

  Let's introduce a type to represent complex numbers

  \begin{columns}[t]

    \begin{column}{.5\textwidth}

  \begin{codeblock}<2->{
struct Complex \{
  \alt<-5>{\ddd
  }{double r; // data member
  double i;}
\};

\uncover<3->{double norm2(Complex c);
Complex sqrt(Complex c);

Complex c\{\alt<-5>{\ddd}{1., 2.}\};
double n = norm2(c);
Complex c2 = sqrt(c);}

\uncover<4->{Complex& cr = c;  // reference}}\end{codeblock}

    \end{column}

    \begin{column}{.5\textwidth}
      \begin{codeblock}<5->{
double norm2(Complex c) \{
  return \uncover<7->{c\alert<7>{.}r * c\alert<7>{.}r + c\alert<7>{.}i * c\alert<7>{.}i};
\}

\uncover<8->{double norm2(Complex\alert<8>{ const\&} c) \{
  return \uncover<9->{c.r * c.r + c.i * c.i};
\}}}\end{codeblock}

      \begin{itemize}
      \item<6-> A \code{Complex} is composed of two \code{double}s
      \item<7-> The \code{.} (dot) operator allows to access a member of an
        object of class type (such as a \code{struct})
      \end{itemize}
    \end{column}

  \end{columns}

  \begin{tikzpicture}[
      anchor=south west,
      node distance=0,
    ]
    
    \visible<3->{
      \node at (0,0) [memory] {};

      \node at (2.9,-0.1) [
        rectangle,
        "\code{c}" below,   
        fill=green!10!white,
        draw=black!40,
        minimum width=2.2cm,
        minimum height=0.7cm,
      ] {};
    }
    \visible<6->{
      \node (r) at (3,0) [word, "\code{r}" above] {\only<6->{1.}};
      \node (i) [word, right=of r, "\code{i}" above] {\only<6->{2.}};
    }
    
  \end{tikzpicture}

\end{frame}

\begin{frame}[fragile]{Operations}

  It's possible to define operations on user-defined types

  \begin{codeblock}
struct Complex \{
  double r;
  double i;
\};

\uncover<3->{bool \uncover<4->{\alert<4>{operator==}}(Complex const& a, Complex const& b) \{
  return a.r == b.r && a.i == b.i;
\}}

\uncover<5->{Complex \uncover<6->{\alert<6>{operator+}}(Complex const& a, Complex const& b) \{
  return Complex\{a.r + b.r, a.i + b.i\};
\}}

c2 \alert<2>{=} c1\uncover<2->{       // \alert<2>{generated by the compiler, if used}}
c1 \alert<3-4>{==} c2
c1 \alert<5-6>{+} c2
z = z * z + c
2. * c1
\ddd\end{codeblock}

\uncover<7>{}

\end{frame}

\begin{frame}[fragile]{Operator overloading}


  \begin{itemize}[<+->]
  \item \Cpp{} offers the possibility to define the meaning of most of the
    operators available for fundamental types when applied to user-defined types
  \item Syntactically this is done via the definition of appropriate functions
  \item Given an operator \textit{@}, the function name is called
    \code{operator\textit{@}}
  \item Although there are some constraints on the number and types of the
    parameters and on the type of the return value, the overloaded operators
    are just functions
  \item The behaviour of the overloaded operator should reproduce the behaviour
    of the original one
  \item Some behaviours cannot be changed, e.g. associativity
  \end{itemize}

\end{frame}

\begin{frame}{Exercises}
  \begin{itemize}
  \item Define some other operators and functions for Complex
  \item Write a function to compute the solutions of an equation of the form
    $ax^2 + bx + c = 0$, given the three coefficients
  \end{itemize}
\end{frame}

\begin{frame}{\Cpp{} standard evolution}

  \begin{itemize}
  \item Working drafts, almost the same as the final published document
    \begin{description}
    \item [\Cpp{}03] \url{https://wg21.link/n1905}
    \item [\Cpp{}11] \url{https://wg21.link/std11}
    \item [\Cpp{}14] \url{https://wg21.link/std14}
    \item [\Cpp{}17] \url{https://wg21.link/std17}
    \item [\Cpp{}20] \url{https://wg21.link/std20}
    \item [\Cpp{}2b] \url{https://wg21.link/std} (current draft, will become
      \Cpp{}23)

      Available also at \url{https://eel.is/c++draft} in HTML format
    \end{description}

    \LaTeX sources at \url{https://github.com/cplusplus/draft}

  \item The default mode for \code{g++} v. 9 (the default compiler on Ubuntu
    20.04) is \Cpp{}14, but occasionally we'll enable \Cpp{}17/20/2b
    \begin{itemize}
    \item \code{g++ -std=c++17 \ddd}
    \end{itemize}
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{\code{auto}}

  Let the compiler deduce the type of a variable from the initializer, i.e. from
  the expression used to initialize the object

  \begin{codeblock}<2->{
auto z;                \uncover<3->{// error, no initializer
auto i = 0;            }\uncover<4->{// int
auto const f = 0.F;    }\uncover<5->{// float const
auto r = i + f;        }\uncover<6->{// float
auto c = Complex\{1,2\}; }\uncover<7->{// Complex
auto& rc = c;          }\uncover<8->{// Complex&
auto const& cri = i;   }\uncover<9->{// int const&
auto j = ri;           }\uncover<10->{// int - auto never deduces a reference
auto& g = f;           }\uncover<11->{// float const& - the constness is preserved
auto& rcr = c.r;       }\uncover<12->{// double&
auto& crcr = std::as_const(c).r; }\uncover<13->{// double const&}}\end{codeblock}

\end{frame}

\begin{frame}[fragile]{\code{auto}/trailing return type}

  \begin{itemize}
  \item When the return type of a function is \code{auto} the compiler will
    deduce it from the return statement(s)
    \begin{itemize}
    \item Only usable in a function definition
    \end{itemize}

    \begin{codeblock}
auto isqrt(int n)
\{
  int result;
  \ddd
  return result;
\}
\end{codeblock}

  \item<2-> If there are multiple return statements their expressions must have the
    same type
  \item<3-> Trailing return type
    \begin{codeblock}
int foo(\ddd);
auto foo(\ddd) -> int; // equivalent\end{codeblock}

  \end{itemize}

\end{frame}

\begin{frame}[fragile]{More data abstraction}

  Imagine to change the Complex type to use the polar form

  \begin{codeblock}
struct Complex \{
  double rho;
  double theta;
\};\end{codeblock}

  \begin{itemize}
  \item<2-> As a consequence, all client code has to change
    \begin{codeblock}
double norm2(Complex const& c) \{ return c.rho * c.rho; \}\end{codeblock}
  \item<3-> Not all combinations of $(\rho,\theta)$ are valid
    \begin{itemize}
    \item $\rho \geq 0, \theta \in [0, 2\pi)$
      \begin{codeblock}
Complex c\{-1, -1\}; // valid?
c.rho = -1;        // valid?\end{codeblock}
    \end{itemize}
  \end{itemize}

  \begin{itemize}
  \item<4-> We wish we could
    \begin{itemize}
    \item have more isolation between client code and implementation
    \item enforce an internal relation (\textit{class invariant}) between data
      members
    \end{itemize}
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Private representation, public interface}

  \begin{itemize}
  \item The internal representation of a data structure should be considered an
    implementation detail
  \item The manipulation of objects should happen through a
    well-defined function-based interface
  \item Known as \alert{encapsulation}
  \end{itemize}

\begin{codeblock}<2->{
\alert<2>{class} Complex \{
 \alert<2-4>{private}: // cartesian form
  double r;
  double i;
 \alert<2>{public}:
  // associated functions (member functions, also known as methods)
\};

\uncover<3->{Complex c\{1., 2.\}; // \alert<3>{error}}
\uncover<4->{double norm2(Complex const& c) \{
  return c\alert<4>{.r} * c\alert<4>{.r} + c\alert<4>{.i} * c\alert<4>{.i}; // \alert<4>{error}
\}}}\end{codeblock}

\end{frame}

\begin{frame}[fragile]{Construction}

  \begin{itemize}
  \item A special function, called \alert{constructor}, can be associated to a
    class to initialize the storage of an object of that type when it is created
  \item The constructor's name is the same as the class name
  \end{itemize}

  \begin{codeblock}<2->{
class \alert<2>{Complex} \{
 private:
  double r;
  double i;
 public:
  \alert<2>{Complex}(double x, double y)\only<2>{ // no return type}
  \uncover<3->{    : r\{x\}, i\{y\} // \alert<3>{member initialization list}}
  \{
    \uncover<4->{// nothing else to do}
  \}
  ...
\};

Complex c\{1., 2.\}; // or (1., 2.)}\end{codeblock}

\end{frame}

\begin{frame}[fragile]{Private representation, public interface \insertcontinuationtext}

  \begin{itemize}
  \item The internal representation of a class should be considered an
    implementation detail
  \item The manipulation of objects should happen through a
    well-defined function-based interface
  \end{itemize}

\begin{codeblock}
class Complex \{
 \alert<1>{private}:
  double r;
  double i;
 \alert<2>{public}:
  Complex(double x, double y) : r\{x\}, i\{y\} \{\}
  \visible<2->{double \alert<2>{real}() \{ return r; \}\only<2>{ // member function (method)}
  double \alert<2>{imag}() \{ return i; \}}
\};

double norm2(Complex c) \{
  return \only<1>{c\alert{.r} * c\alert{.r} + c\alert{.i} * c\alert{.i}; // \alert{error}}\only<2->{c\alert<2>{.real()} * c\alert<2>{.real()} + c\alert<2>{.imag()} * c\alert<2>{.imag()};}
\}\end{codeblock}

\end{frame}

\begin{frame}[fragile]{Private representation, public interface
    \insertcontinuationtext}

  \begin{itemize}
  \item Member functions (methods) can of course also mutate an object
    \begin{codeblock}
class Complex \{
 public:
  void add(Complex const& other) \{
    r += other.r;
    i += other.i;
  \}
  \ddd
\};

Complex c\{1., 2.\};
Complex d\{3., 4.\};
c.add(d);
c.real(); // 4.

\visible<2->{
c.add(Complex\{3., 4.\}); // valid
c.add(\{3., 4.\});        // also valid}\end{codeblock}

  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Private representation, public interface
    \insertcontinuationtext}

  \begin{itemize}
  \item Member functions that don't modify the object should be declared
    \textbf{\code{const}}

\begin{codeblock}
class Complex \{
 private:
  double r;
  double i;
 public:
  Complex(double x, double y) : r\{x\}, i\{y\} \{\}
  double real()\only<2>{ \alert{const}} \{ return r; \}\only<1>{ // could modify data members}
  double imag()\only<2>{ \alert{const}} \{ return i; \}
\};

double norm2(Complex \alert{const}& c) \{
  return c.real() * c.real() + c.imag() * c.imag();\only<1>{ // \alert{error}}
\}\end{codeblock}

  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Private representation, public interface
    \insertcontinuationtext}

  \begin{itemize}

  \item It's not rare to have functions with the same name, but in two different
    forms: one that reads and one that modifies the internal state
    \begin{itemize}
    \item Example of function overloading in action
    \end{itemize}

    \begin{codeblock}
class Complex \{
 public:
  double real()         const \{ return r; \}
  void   real(double d)       \{ r = d; \}
  \ddd
\};\end{codeblock}

    \begin{columns}
      \begin{column}{.5\textwidth}
        \begin{codeblock}
Complex c\{1.,2.\};
c.real(0.);
c.real();           // return 0.\end{codeblock}
      \end{column}
      \begin{column}{.5\textwidth}
        \begin{codeblock}
Complex const c\{1.,2.\};
c.real(0.);         // error
c.real();           // ok\end{codeblock}
      \end{column}
    \end{columns}
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Member vs free function}
  \begin{codeblock}
class Complex \{
 public:
  double norm2() const \{ // \alert<1>{member function}
    return r * r + i * i;
  \}
  ...
\};

double norm2(Complex const& c) \{ // \alert<1>{free function}
  return c.real() * c.real() + c.imag() * c.imag();
\}

Complex c\{\ddd\};
c.norm2(); // call the member function
norm2(c);  // call the free function\end{codeblock}

  \pause
  \begin{itemize}
  \item The public part of a class should ideally provide a safe, efficient and
    complete interface, yet minimal
  \item Prefer a free function, if possible
    \begin{itemize}
    \item Extend the functionality of a class without modifying existing code
    \end{itemize}
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{\code{std::string} \insertcontinuationtext}

  \begin{itemize}

  \item A user-defined type to represent a sequence of characters
  \item Provided by the C++ Standard Library
  \item Provides (too) many member functions
    \begin{itemize}
    \item Construction
    \item Capacity (e.g. \code{size()}, \code{empty()})
    \item Assignment (e.g. \code{=}, \code{assign()})
    \item Comparison (\code{==}, \code{!=}, \code{<}, \code{>}, \code{<=}, \code{>=})
    \item Access to a character (e.g. \code{[]}, \code{back()}, \code{front()})
    \item Insertion/removal (e.g. \code{insert()}, \code{append()}, \code{erase()})
    \item Search (e.g. \code{find()})
    \item \ldots
    \end{itemize}
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Construction \insertcontinuationtext}

  \begin{codeblock}<1->{
class Complex \{
 private:
  double r\alt<4-5>{\alert{ = 0.}; // \alert{default member initializer}}{;}
  double i\alt<4-5>{\alert{ = 0.};}{;}
 public:
  \only<1>{


  }\only<2>{Complex(double x, double y) : r\{x\}, i\{y\} \{\}
  Complex(double x) : r\{x\}, i\{0.\} \{\}
  Complex() : r\{0.\}, i\{0.\} \{\} // \alert{default constructor}
  }\only<6->{Complex(double x \alert<6>{= 0.}, double y \alert<6>{= 0.})\only<6>{ // \alert{default arguments}}
       : r\{x\}, i\{y\} \{\}

  }\only<4-5>{Complex(double x, double y) : r\{x\}, i\{y\} \{\}
  Complex(double x) : r\{x\} \{\}
  Complex() \only<4>{\{\}}\only<5>{\alert{= default};}
  }\only<3>{Complex(double x, double y) : r\{x\}, i\{y\} \{\}
  Complex(double x) : Complex\{x, 0.\} \{\} // \alert{delegating constructor}
  Complex() : Complex\{0., 0.\} \{\}        // \alert{delegating constructor}
  }
\};

Complex c1\{1., 2.\};
Complex c2\{1.\}; // meaning \{1., 0.\}
Complex c3; // or \{\}, meaning \{0., 0.\}; () cannot be used here}\end{codeblock}

  \begin{itemize}
  \item<7-> A constructor should initialize the data members in order to
    establish the \textit{class invariant}
  \item<8-> The default constructor can be automatically generated by the
    compiler, but only if there are no other constructors
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{\code{explicit} constructor}

  \begin{codeblock}
class Complex \{
  Complex(double x = 0., double y \alert<2-3>{= 0.}) : r\{x\}, i\{y\} \{\}
  \ddd
\};

double norm2(Complex const& c) \{ \ddd \}

norm2(1.);\uncover<2->{ // callable with a double (-> Complex)}
\uncover<3->{norm2(1);  // callable with an int (-> double -> Complex)}
\uncover<4->{c + 3;     // call operator+ with two Complex}
\uncover<5->{3 + c;     // call operator+ with two Complex, only if free function}\end{codeblock}

  \begin{itemize}
  \item<2-> The (one-parameter) constructor is used for the conversion
  \item<6-> An \code{explicit} constructor prevents the implicit conversion
  \end{itemize}

  \begin{codeblock}<6->{
class Complex \{
  \alert{explicit} Complex(double x = 0., double y = 0.) \ddd
  \ddd
\};

norm2(1.);          // error
norm2(Complex\{1.\}); // ok}\end{codeblock}

\end{frame}

\begin{frame}[fragile]{\code{explicit} constructor \insertcontinuationtext}

  \begin{itemize}
  \item An \code{explicit} constructor prevents also the implicit construction
    of an object from a list of arguments between braces
    \begin{itemize}
    \item e.g. in a function call or in a \code{return} statement
    \end{itemize}
  \end{itemize}

  \begin{columns}[t]
    \begin{column}{.45\textwidth}
      \begin{codeblock}
class Complex \{
  Complex(double x, double y) \ddd
  \ddd
\};

Complex operator+(\ddd)
\{
  \ddd
  return \{r, i\}; // ok
\}\end{codeblock}

    \end{column}

    \begin{column}{.55\textwidth}
      \begin{codeblock}
class Complex \{
  \alert{explicit} Complex(double x, double y) \ddd
  \ddd
\};

Complex operator+(\ddd)
\{
  \ddd
  // return \{r, i\}; // error
  return Complex\{r, i\}; // ok
\}\end{codeblock}

    \end{column}

  \end{columns}

  \begin{itemize}
  \item<2> Better start with explicit constructors, especially for one callable
    with one argument, and relax the constraint later
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{\code{operator@} in terms of \code{operator@=}}

  \begin{itemize}
  \item Typically, a symmetric \code{operator@} (e.g. \code{operator+}) is
    implemented in terms of a member \code{operator@=} (e.g. \code{operator+=})
    \begin{codeblock}
Complex operator+(Complex const& lhs, Complex const& rhs)
\{
  Complex result\{lhs\}; // create the result as a copy of lhs
  result += rhs;       // add rhs to the result
  return result;       // return it
\}\end{codeblock}

  \item<2-> Typically, \code{operator@=} returns a reference to the object being
    operated on

    \begin{codeblock}
class Complex \{
  \ddd
  Complex\alert{&} operator+=(Complex const& rhs) \{
    r += rhs.r; i += rhs.i;
    return \alert{*this};
  \}
\};\end{codeblock}

    \code{*this} means \textit{self}, see later in the course
  \end{itemize}
\end{frame}

\begin{frame}{Example: rational numbers}

  \begin{itemize}
  \item Let's implement a class to represent rational numbers
  \item The representation is with two integers, such that
    \begin{itemize}
    \item The fraction is irreducible, i.e. their GCD (Greatest Common
      Denominator) is $1$
    \item If the number is negative the sign is kept in the numerator
    \item The denominator is different from $0$
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Example: rational numbers \insertcontinuationtext}

  \begin{codeblock}
class Rational
\{
  int n_;
  int d_;
 public:
  Rational(int num = 0, int den = 1) : n_\{num\}, d_\{den\}
  \{
    if (d_ == 0) \{
      // construction must fail
    \}
    // reduce  
    auto const g = std::gcd(n_, d_); // in <numeric>
    n_ /= g;
    d_ /= g;
    // fix sign
    if (d_ < 0) \{
      n_ = -n_;
      d_ = -d_;
    \}
  \}
  \ddd
\};\end{codeblock}

\end{frame}

\begin{frame}{Class invariant}

  \begin{itemize}[<+->]
  \item A \textbf{class invariant} is a relation between the data members of a
    class that constrains the values that such members can assume
    \begin{itemize}
    \item It defines what is a valid state for an object of that class
    \item It must always hold for an object of that class
    \end{itemize}
  \item The invariant is established by the constructor
  \item The invariant is preserved by \textbf{public} methods
    \begin{itemize}
    \item The invariant holds when the function is entered $\implies$ the
      implementation can make assumptions
    \item The invariant may be violated during the execution of the function
    \item The invariant is re-established before exiting the function
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{\code{assert}}

  Check that a certain boolean expression is satisfied at run time
  \begin{itemize}
  \item for example, a class invariant at the end of a constructor or a
    condition at the beginning of a function (a \textit{pre-condition})
  \end{itemize}

  \begin{codeblock}<2->{
#include <cassert>

class Rational \{
  \ddd
  Rational(int num = 0, int den = 1) : n\{num\}, d\{den\} \{
    \ddd
    assert(std::gcd(n, d) == 1 && d > 0);
  \}
  Rational& operator/=(int n) \{
    assert(n != 0);
    \ddd
  \}
\};

bool operator==(Rational const& l, Rational const& r)
\{
  assert(std::gcd(l.num(), l.den()) == 1 && std::gcd(r.num(), r.den()) == 1);
  return l.num() == r.num() && l.den() == r.den();
\}}\end{codeblock}

\end{frame}

\begin{frame}[fragile]{\code{assert} \insertcontinuationtext}

  \begin{itemize}
  \item If the asserted condition is not satisfied, it means that the state of the
    program does not conform to the expectations of the programmer, i.e. to the
    design
  \item The state may even be corrupted $\rightarrow$ it's probably wiser to
    \code{terminate} the program as soon as possible to avoid causing damage
  \item Useful during testing/debugging
  \item Can be disabled for performance reasons (\code{g++ -DNDEBUG \ddd})
    \begin{itemize}
    \item Avoid side effects in \code{assert}s (e.g. assignments or calls to
      non-const methods), because they would disappear from the executable
    \end{itemize}
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{\code{assert} \insertcontinuationtext}

  \begin{itemize}
  \item \code{assert} (but also Doctest's \code{CHECK}) is a
    \textit{preprocessor macro}
  \item Macros obey syntactic rules that are different from those of C++ proper

    \begin{codeblock}<2->{
assert(Rational\{1\alert{,}2\} == Rational\{2\alert{,}4\});   // error (*)
assert(Rational\alert{(}1,2\alert{)} == Rational\alert{(}2,4\alert{)});   // ok
assert(\alert{(}Rational\{1,2\} == Rational\{2,4\}\alert{)}); // ok}\end{codeblock}

    {\tiny\begin{itemize}
    \item[*]<2-> macro "assert" passed 3 arguments, but takes just 1
    \end{itemize}}
  \item<3-> Macros \textit{expand} to arbitrary text, which is then passed to the
    real C++ compiler
  \item<3-> A bit more about the preprocessor later in the course
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Exceptions}

  \begin{itemize}
  \item Exceptions provide a general mechanism to:
    \begin{itemize}
    \item notify the occurrence of an error in the program execution
      \begin{itemize}
      \item using a \code{throw} expression
      \end{itemize}
    \item transfer control to a handler defined in a previous function in the call
      chain
      \begin{itemize}
      \item using a \code{try}/\code{catch} statement
      \end{itemize}
    \end{itemize}
  \item<2-> Exceptions help separate application logic from error management
  \item<3-> A typical use is in constructors and operators
  \item<4-> Exceptions cannot be ignored
    \begin{itemize}
    \item If a handler is not found the program is \code{terminate}d
    \end{itemize}
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Exceptions \insertcontinuationtext}
  \begin{columns}

    \begin{column}{.5\textwidth}
      \begin{codeblock}
struct E \{\};

auto low() \{
  \ddd // this part is executed
  \alert{throw} E\{\};
  \ddd // this part is not executed
\}

auto mid() \{
  \ddd // this part is executed
  low();
  \ddd // this part is not executed
\}

auto high() \{
  \alert{try} \{
    \ddd // this part is executed
    mid();
    \ddd // this part is not executed
  \} \alert{catch} (E& e) \{
    \ddd // use e
  \}
\}\end{codeblock}
    \end{column}

    \begin{column}{.5\textwidth}
      \begin{itemize}[<+->]
      \item An exception is an object
      \item After being raised (\code{throw}n), an exception is propagated up the stack
        of function calls until a suitable \code{catch} clause (handler) is
        found
      \item If no suitable handler (i.e. one compatible with the type of the
        exception) is found the program is \code{terminate}d
      \item Exceptions should be caught by (const) reference
      \item During \textit{stack unwinding} the stack frames are properly
        cleaned up
      \end{itemize}
    \end{column}

  \end{columns}

\end{frame}

\begin{frame}[fragile]{Exceptions in constructors}

  \begin{itemize}
  \item An exception is typically raised by a constructor to inform that it is
    not able to properly initialize the object
    \begin{itemize}
    \item i.e. it's not able to establish the class invariant
    \end{itemize}
  \item Let's apply this to Rational, using the standard-provided exception \code{std::runtime_error}
    \begin{itemize}
    \item it can be constructed with a string or a string literal
    \item it provides a \code{what()} method to retrieve that string, e.g. in
      the handler
    \end{itemize}
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Exceptions in constructors \insertcontinuationtext}

    \begin{codeblock}
#include <stdexcept>

class Rational \{
  \ddd
  Rational(int num = 0, int den = 1) : n\{num\}, d\{den\} \{
    if (d == 0) \{
      \alert{throw} std::runtime_error\{"denominator is zero"\};
    \}
    \ddd
  \}
\};

int main() \{
  \alert{try} \{
    Rational r1\{1,0\};
    \ddd
  \} \alert{catch} (std::runtime_error const& e) \{
    std::cerr << e.what() << \bslashn;
  \}
\}\end{codeblock}

\end{frame}

\begin{frame}{Assertions or exceptions?}

  \begin{itemize}
  \item There is no general rule, at best guidelines
  \item<2-> Use an assertion to express your belief about the state of a program
    \begin{itemize}
    \item E.g. a class invariant at the end of a constructor and at the
      beginning of a method
    \item Be generous with asserts
    \end{itemize}
  \item<3-> Use an exception to signal that a function can't perform its assigned
    task
    \begin{itemize}
    \item E.g. cannot establish the invariant, cannot allocate enough memory,
      cannot open a file, cannot connect to a web server, \ldots
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Assertions or exceptions? \insertcontinuationtext}

  \begin{itemize}
  \item Use an assertion to express a pre-condition for a function
    \begin{itemize}
    \item I.e. the function is able to perform its task only if its arguments
      satisfy certain constraints (and documents it)
    \item If the condition is not met, termination of the program is the best (or
      least worst) thing to do
    \item E.g. \code{Rational::operator/=} called with $0$
    \item The caller has the responsibility to call properly
    \item But if not meeting the condition is an acceptable situation, use an
      exception
    \end{itemize}
  \item Do \textbf{not} use an \code{assert} to validate input to the program
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{The \code{switch} statement}

  The \code{switch} statement transfers control to one of multiple statements,
  depending on the value of a condition

  \begin{codeblock}<2->{
double compute(char op, double left, double right)
\{
  double result;

  switch (op) \{
    case \upquote{+}:
      result = left + right;
      break;
    \ddd
    case \upquote{/}:
      result = (right != 0.) ? left / right : 0.;
      break;
    default:
      result = 0.;
  \}

  return result;
\}}\end{codeblock}

\end{frame}

\begin{frame}{The \code{switch} statement \insertcontinuationtext}

  \begin{itemize}
  \item The condition is an expression whose evaluation gives an integral (or
    enumeration, see later) value
    \begin{itemize}
    \item Cannot switch on strings, for example
    \end{itemize}
  \item Each statement, possibly compound, is introduced either by a \code{case}
    label or by a \code{default} label
  \item Each \code{case} label specifies a unique integral constant
  \item Typically each statement is followed by a \code{break} statement, to
    jump after the \code{switch}, otherwise control \textit{falls through} the
    next instruction, even if this is part of a statement introduced by another
    label
    \begin{itemize}
    \item The compiler typically warns about falling through, but sometimes it's
      ok and the warning can be silenced with the \code{[[fallthrough]]}
      \textit{attribute}
    \end{itemize}
  \item There can be at most one \code{default} label, not necessarily at the
    end
  \item The same statement can be introduced by multiple \code{case} labels
  \end{itemize}

\end{frame}

\begin{frame}{Exercise}

  Write a function that takes two numeric operands of type double and one
  operator of type char and returns the result of applying that operator to the
  two operands.

  If either the operator is invalid or an operand is invalid, throw a
  user-defined exception that saves internally the operator character and the
  two operands and that has appropriate methods to retrieve them, so that the
  exception handler can print a meaningful error message.

\end{frame}

\begin{frame}[fragile]{The C++ compilation model}

  This is the \textbf{current} model; \Cpp{}20 has introduced \textit{modules}

  \begin{center}
    \begin{tikzpicture}[every text node part/.style={align=center},
      source/.style={
        tape,tape bend height=.15cm,draw,thick,inner sep=4pt
      }
      ]

      \node[source] (source) {Source file \\
        {\scriptsize(\code{hello.cpp})}};

      \node[source,right=3cm of source] (exe) {Executable\\binary file \\ {\scriptsize(\code{a.out})}};

      \draw[thick,-Stealth] (source) -- (exe) node[above,align=center,midway] {Compilation \\ {\scriptsize(\code{g++})}};


      \visible<2->{\node[source,left=2cm of source,yshift=1cm] (iostream) {Header \\
          {\scriptsize(\code{iostream})}\\\hphantom{\scriptsize(\code{string})}};

        \node[source,left=2cm of source,yshift=-1cm] (string) {Header \\
          {\scriptsize(\code{string})}\\\hphantom{{\scriptsize(\code{iostream})}}};

        \draw[thick,dashed,-{Stealth[open]}] (string) -- (source) node[below,midway] {\tiny\code{\#include}};
        \draw[thick,dashed,-{Stealth[open]}] (iostream) -- (source) node[above,midway] {\tiny\code{\#include}};
      }
      \visible<3->{
        \node[inner sep=10pt,rounded corners,draw=red,thick,fit=(iostream) (string) (source)] (tu) {};
        \node[red,above left=2mm of tu.south east,anchor=south east] {Translation Unit};
      }
    \end{tikzpicture}
  \end{center}

  \begin{itemize}
  \item<4-> The production of the \textit{translation unit} is the first step of
    the compilation process
  \item<4-> It is accomplished by running the \textit{preprocessor} on a source file
  \item<5-> To stop the compilation process after the preprocessing:
    \begin{itemize}
    \item \code{g++ -E hello.cpp}
    \end{itemize}
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{The C++ compilation model \insertcontinuationtext}

  \begin{itemize}
  \item A typical C++ program is composed of many files, i.e. there are many
    translation units
    \begin{center}
      \visible<2->{\begin{tikzpicture}[
          every text node part/.style={align=center},
          every node/.style={fill=white,inner sep=3pt},
          source/.style={
            tape,tape bend height=.15cm,draw=red,thick
          },
          binary/.style={
            tape,tape bend height=.15cm,draw=green,thick
          },
          tool/.style={
            single arrow, single arrow head extend=0, draw,thick,
            shape border rotate=0,single arrow tip angle=120
          }
          ]

          \node[source] (sources) {\phantom{Translation}\\\phantom{Units}};
          \foreach \x in {4,...,1} {
            \node[source,very thin,above left=\x mm and \x mm of sources,
            anchor=north west] {\phantom{Translation}\\\phantom{Units}};
          }
          \node[source] at (sources) {Translation\\Units};

          \node[tool,right=1cm of sources] (compiler) {\textit{Compiler}};

          \node[binary,right=1cm of compiler] (exe) {Executable};

          \draw[thick] (sources) -- node[near start,above,inner sep=0,outer sep=1pt] {\scriptsize\textbf{+}} (compiler);
          \draw[thick] (compiler) -- (exe);
        \end{tikzpicture}
      }
    \end{center}
  \item<3-> How to distribute source code over multiple files?
  \item<3-> How to expose functionality from one translation unit so that it can
    be used in another?
  \item<4-> \textbf{Physical} design
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{The C++ compilation model \insertcontinuationtext}

  \begin{itemize}
  \item The overall process to translate C++ source code to the final binary
    executable consists of multiple stages
  \end{itemize}

  \begin{center}
      \begin{tikzpicture}[
        every text node part/.style={align=center},
        every node/.style={fill=white,inner sep=3pt},
        source/.style={
          tape,tape bend height=.15cm,draw=red,thick
        },
        binary/.style={
          tape,tape bend height=.15cm,draw=green,thick
        },
        object/.style={
          tape,tape bend height=.15cm,draw=green!50!black,thick
        },
        tool/.style={
          single arrow, single arrow head extend=0,draw,thick,
          shape border rotate=0,single arrow tip angle=120
        }
        ]

        \node[source] (sources) {\phantom{Translation}\\\phantom{Units}};
        \foreach \x in {4,...,1} {
          \node[source,very thin,above left=\x mm and \x mm of
          sources,anchor=north west]
          {\phantom{Translation}\\\phantom{Units}};
        }
        \node[source] at (sources) {Translation\\Units};


        \node[tool,right=.5cm of sources] (compiler) {Compiler};

        \node[object,right=1cm of compiler,draw=none] (objects) {\phantom{Object}\\\phantom{Files}};
        \foreach \x in {4,...,1} {
          \node[object,very thin,above left=\x mm and \x mm of
          objects,anchor=north west] {\phantom{Object}\\\phantom{Files}};
        }
        \node[object] at (objects){Object\\Files};

        \node[tool,right=.5cm of objects] (linker) {Linker};

        \node[binary,right=.5cm of linker] (exe) {Executable};

        \draw[thick] (sources) -- node[near start,above,inner sep=0,outer sep=1pt] {\scriptsize\textbf{+}} (compiler);
        \draw[thick] (compiler) -- node[near start,above,inner sep=0,outer sep=1pt] {\scriptsize\textbf{+}} (objects);
        \draw[thick] (objects) -- node[near start,above,inner sep=0,outer sep=1pt] {\scriptsize\textbf{+}} (linker);
        \draw[thick] (linker) -- (exe);

        \node[object,above left=1.3cm and 0cm of linker] (libstd) {Standard\\Library};

        \node[object,right=.6cm of libstd,draw=none] (otherlibsph) {\phantom{Other}\\\phantom{Libraries}};
        \foreach \x in {4,...,1} {
          \node[object,very thin,above left=\x mm and \x mm of
          otherlibsph,anchor=north west]
          {\phantom{Other}\\\phantom{Libraries}};
        }
        \node[object] at (otherlibsph) {Other\\Libraries};

        \draw[thick,-Stealth] (libstd) -- (linker);
        \draw[thick,-Stealth] (otherlibsph) -- (linker);

      \end{tikzpicture}
    \end{center}

    \begin{itemize}
    \item<2-> To produce object files without linking:
      \begin{itemize}
      \item \code{g++ -c hello.cpp}
      \end{itemize}
    \item<2-> To keep all the intermediate files generated during the compilation process:
      \begin{itemize}
      \item \code{g++ -save-temps hello.cpp}
      \end{itemize}
    \end{itemize}

\end{frame}

\begin{frame}[fragile]{Definition vs Declaration}

  \begin{itemize}
  \item A \alert{definition} is a declaration that fully defines an entity
  \item Examples:
  \end{itemize}

  \begin{codeblock}
bool less_than(int a, int b) \{ // function definition
  return a < b;
\}

class Regression \{ // class definition
 public:
  void add(Point const& p) // member function definition
  \{
    ++N_;
    sum_x_ += p.x;
    \ddd
  \}
  \ddd
\};

int num; // (global) variable definition\end{codeblock}

\end{frame}

\begin{frame}[fragile]{Definition vs Declaration \insertcontinuationtext}

  \begin{itemize}
  \item A \alert{declaration} that is \textbf{not} a definition just introduces
    the name (and, when applicable, the type) of the entity
  \item Examples:
  \end{itemize}

  \begin{codeblock}
bool less_than(int, int); // function declaration (signature/prototype)

class Regression; // class (forward) declaration

class Regression \{ // class definition
 public:
  void add(Point const& p); // member function declaration
  \ddd
\};

extern int num; // variable declaration (no initializer)\end{codeblock}

\end{frame}

\begin{frame}{One-Definition Rule (ODR)}
  \begin{itemize}[<+->]
  \item An entity can be defined only once in each translation unit
  \item More generally, an entity can be defined only once in the whole program,
    with exceptions
  \item Some entities can be defined in multiple translation units, provided the
    definitions are identical (\textit{token-by-token} in the source code)
    \begin{itemize}[<.->]
    \item Class definitions
    \item \textit{inline} functions and variables
    \item Class and function templates
    \item \ldots
    \end{itemize}
  \item To guarantee that definitions are identical in all translation units
    they typically appear in \textbf{header files}, which are then
    \code{\#include}d where needed
  \item The compiler may not be able to diagnose violations of the ODR
  \end{itemize}
\end{frame}

\begin{frame}{Definition vs Declaration during compilation and linking}

  \begin{itemize}[<+->]
  \item During the compilation step:
  \begin{itemize}
  \item Calling a function requires the declaration of that function
  \item The declaration of a function requires the declaration of the types
    involved
  \item Creating and manipulating an object require the definition of the
    corresponding type (the type has to be \textit{complete})
  \end{itemize}

\item During the linking step:

  \begin{itemize}
  \item Everything has to be properly defined
  \end{itemize}
    \end{itemize}

\end{frame}

\begin{frame}{Header and source files}

  \begin{itemize}[<+->]
  \item Header files are the primary mechanism to guarantee that declarations
    and definitions are identical in all translation units
    \begin{itemize}[<.->]
    \item Because they are \code{\#include}d in other header and source files
      where those declarations and definitions are needed
    \end{itemize}
  \item For a given software component, a typical situation foresees
    \begin{itemize}
    \item One \textbf{header} file containing free function declarations, class
      definitions with member function declarations, template definitions
    \item One \textbf{source} file containing definitions of free and member functions
      and of any other entity needed for the implementation
      \begin{itemize}
      \item \textbf{Suggestion} the source file \code{\#include}s the header
        file as the first \code{\#include}
      \end{itemize}
    \item One file with the unit \textbf{tests}
    \end{itemize}
  \item A function defined in a header file needs to be
    \code{inline}
    \begin{itemize}
    \item NB the \code{inline} keyword is not (any more) an optimization hint to
      the compiler
    \end{itemize}
  \item Member functions (methods) defined inside the class and function
    templates are implicitly \code{inline}
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Member functions defined outside the class}

  \begin{itemize}

  \item A method must be declared inside the class, but can be \textbf{only}
    declared inside the class, i.e. not defined

    \begin{codeblock}
class Regression \{
  \ddd
  void add(Point const&);
\};\end{codeblock}

  \item When defining a method outside the class, the method name must be
    prefixed with the class name followed by the \textit{scope} operator
    \code{::}, i.e. \textit{class-name}\code{::}\textit{method-name}

    \begin{codeblock}
void Regression::add(Point const& p) \{
  ++N_;
  sum_x_ += p.x;
  \ddd
\}\end{codeblock}

  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Member functions defined outside the class \insertcontinuationtext}

  \begin{itemize}
  \item The method can be defined in the same file (normally a header file) or
    even in another file (normally the corresponding source file)

  \item If the definition is in a header file, the method should be declared \code{inline}

    \begin{codeblock}
\alert{inline} void Regression::add(Point const& p) \{
  ++N_;
  sum_x_ += p.x;
  \ddd
\}\end{codeblock}

    This informs the compiler/linker that all the definitions of the function, even
    if they are in multiple translation units, are equal

  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Include guards}

  \begin{itemize}[<+->]
  \item A header (file) may be included, directly or indirectly, multiple times
    in the \textbf{same} translation unit
    \begin{codeblock}
#include "point.hpp"
#include "regression.hpp" // regression.hpp includes point.hpp\end{codeblock}

  \item Multiple definitions of the same entity would be available in the
    \textbf{same} translation unit, which is illegal
  \item Placing an \textit{include guard} at the beginning of each header file
    prevents multiple inclusions in the \textbf{same} translation unit
    \begin{codeblock}
// file point.hpp
#ifndef POINT_HPP
#define POINT_HPP
\ddd
// classes, functions, templates, \ldots
\ddd
#endif\end{codeblock}
  \end{itemize}
\end{frame}

\begin{frame}{To inline or not to inline?}

  \begin{itemize}
  \item Pros:
    \begin{itemize}
    \item A compiler can optimize more because it sees more code $\rightarrow$
      faster execution
    \item Header-only libraries (i.e. everything is in one or more header files)
      are easier to distribute (e.g. \code{doctest})
    \end{itemize}
  \item Cons:
    \begin{itemize}
    \item More physical coupling between software components
      \begin{itemize}
      \item Visibility of implementation details
      \item Every time a header file changes all the including files need to be
        recompiled $\rightarrow$ longer compilation times
      \end{itemize}
    \item The code of the inlined functions may be included many times in the
      final binary, making it larger and causing inefficient use of the memory
      system $\rightarrow$ slower execution
    \end{itemize}
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Class template}

  \begin{itemize}
  \item<1-> Let's consider again the \code{Complex} class
  \item<2-> What if we want \code{float} members?
  \end{itemize}

  \begin{columns}[t]

  \begin{column}{.5\textwidth}
    \begin{codeblock}<1->{
\visible<0>{template<typename \alert{F}>}
class Complex \{
  \alert{double} r;
  \alert{double} i;
 public:
  Complex(
      \alert{double} x = \alt<-2>{0.}{\alert<3->{double}\{\}}
    , \alert{double} y = \alt<-2>{0.}{\alert<3->{double}\{\}}
  ) : r\{x\}, i\{y\} \{\}
  \alert{double} real() const \{ return r; \}
  \alert{double} imag() const \{ return i; \}
\};}\end{codeblock}

  \end{column}
  \begin{column}{.5\textwidth}
    % keep the alerts as are, even if it seems non-optimal, to preserve the
    % spaces after FP
    \begin{codeblock}<2->{
\visible<5->{template<typename \alert{FP}> // (*)}
class Complex \{
  \alt<-3>{\alert{float}}{\alert{FP}   } r;
  \alt<-3>{\alert{float}}{\alert{FP}   } i;
 public:
  Complex(
      \alt<-3>{\alert{float}}{\alert{FP}   } x = \alt<2>{0.\alert{F}}{\alt<-3>{\alert{float}}{\alert{FP}   }\{\}}
    , \alt<-3>{\alert{float}}{\alert{FP}   } y = \alt<2>{0.\alert{F}}{\alt<-3>{\alert{float}}{\alert{FP}   }\{\}}
  ) : r\{x\}, i\{y\} \{\}
  \alt<-3>{\alert{float}}{\alert{FP}   } real() const \{ return r; \}
  \alt<-3>{\alert{float}}{\alert{FP}   } imag() const \{ return i; \}
\};}\end{codeblock}

\uncover<5>{\scriptsize\begin{itemize}
  \item[*] Or, \code{template<class FP>}
  \end{itemize}}

  \end{column}

  \end{columns}

\uncover<3->{}
\uncover<4->{}

\end{frame}

\begin{frame}[fragile]{Class template \insertcontinuationtext}

  \begin{codeblock}{
template<typename FP>
class Complex \{
  \uncover<8->{\alert<8>{static_assert(std::is_floating_point_v<FP>);} // (*)}
  FP r;
  FP i;
 public:
  Complex(FP x = FP\{\}, FP y = FP\{\}) : r\{x\}, i\{y\} \{\}
  \alt<1>{FP  }{\alert<2>{auto}} real() const \{ return r; \}
  \alt<1>{FP  }{\alert<2>{auto}} imag() const \{ return i; \}
\};

\uncover<3->{Complex c;                     // error}
\uncover<4->{Complex<double> d;             // instantiation of a Complex<double> type}
\uncover<4->{Complex e\{1.,1.\};              // Complex<double> deduced, C++17}
\uncover<5->{Complex<float> f;              // different type than d}
\uncover<6->{d \alert<6>{+} e;                         // ok
d \alert<6>{+} f;                         // possibly error}
\uncover<7->{Complex<int> i;                // \alt<7>{acceptable?}{\alert<8>{error}}}}\end{codeblock}

\uncover<8>{\scriptsize\begin{itemize}
  \item[*] compile-time check + type introspection
  \end{itemize}}

\end{frame}

\begin{frame}{Class template \insertcontinuationtext}
  \begin{itemize}
  \item A class template is a type \textit{generator}
  \item A class template is parameterized by one or more template parameters
    (types, but not only)
  \item A template \textit{specialization} identifies a template name and a set
    of template arguments corresponding to the template parameters
    \begin{itemize}
    \item Template arguments can be explictly specified (e.g. following the
      template name between angular brackets \code{<>}) or deduced based on
      constructor arguments
    \end{itemize}
  \item When a class template specialization is used in a context where a type
    is needed, the compiler \textit{instantiates} a new type
    \begin{itemize}
    \item Identical instantiations are merged together
    \end{itemize}
  \item Only member functions that are actually used are instantiated
  \item There are ways to constrain the arguments used to instantiate a template
    \begin{itemize}
    \item Notably, \Cpp{}20 has introduced \textit{concepts}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Function template}

  \begin{codeblock}<1->{
double norm2(Complex const\& c) \{ \ddd \} // not valid any more
norm2(f);                             // error; f is of type Complex<float>}\end{codeblock}

  \begin{codeblock}<2->{
auto norm2(Complex<\alert<4-5>{float}> const\& c) \{
  return c.real() * c.real() + c.imag() * c.imag();
\}
norm2(f); // ok
norm2(d); // error; d is of type Complex<double>}\end{codeblock}

  \begin{codeblock}<3->{
auto norm2(Complex<\alert<4-5>{double}> const\& c) \{
  return c.real() * c.real() + c.imag() * c.imag();
\}
norm2(d); // ok}\end{codeblock}

  \begin{codeblock}<5->{
template<typename \alert<5>{FP}>
auto norm2(Complex<\alert<5>{FP}> const\& c) \{
  return c.real() * c.real() + c.imag() * c.imag();
\}
\uncover<6>{auto nf = norm2(f); // nf is of type float
auto nd = norm2(d); // nd is of type double}}\end{codeblock}

\end{frame}

\begin{frame}[fragile]{Function template \insertcontinuationtext}

  \begin{codeblock}
template<typename \alert<2>{FP}>
auto norm2(\alert<2>{Complex<FP>} const\& c)
\{ return c.real() * c.real() + c.imag() * c.imag(); \}

\uncover<2->{template<typename \alert<2>{C}>
auto norm2(\alert<2>{C} const\& c)
\{ return c.real() * c.real() + c.imag() * c.imag(); \}}

\uncover<3->{norm2(f); // ok}
\uncover<4->{norm2(d); // ok}
\uncover<5->{std::complex<float> g;
norm2(g); // ok!}

\uncover<6->{namespace std \{
  template<class T>
  class complex \{
    \ddd
   public:
    T real() const;
    T imag() const;
  \};
\}}\end{codeblock}

  \begin{textblock}{6}(6,5)
    \visible<7->{This shows the basic idea behind \alert<7>{generic programming}}
  \end{textblock}

\end{frame}

\begin{frame}{Function template \insertcontinuationtext}
  \begin{itemize}
  \item A function template is a function \textit{generator}
  \item A function template is parameterized by one or more template parameters
    (types, but not only)
  \item A template \textit{specialization} identifies a template name and a set
    of template arguments corresponding to the template parameters
    \begin{itemize}
    \item Template arguments can be explictly specified (e.g. following the
      template name between angular brackets \code{<>}) or deduced based on
      function arguments
    \end{itemize}
  \item When a function template specialization is used in a context where a
    function is needed, the compiler \textit{instantiates} a new function
    \begin{itemize}
    \item Identical instantiations are merged together
    \end{itemize}
  \item Only functions that are actually used are instantiated
  \item There are ways to constrain the arguments used to instantiate a template
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Template argument deduction}

  \begin{itemize}
  \item In order to instantiate a template every template argument has to be
    known
  \item For function templates, C++ has always supported the possibility to
    deduce the template arguments from function call arguments
    \begin{codeblock}
template<class F> F norm2(Complex<F> const& c) \{\ddd\}

Complex<float> f;
norm2(f);          // no need to specify norm2<float>(f)
norm2<float>(f);   // ok, be explicit
norm2<double>(f);  // (almost) ok, instantiate and call norm2<double>\end{codeblock}

  \item Sometimes there are not enough function parameters
    \begin{codeblock}
template<class To, class From>
To convert_to(From const& f) // a sort of static_cast
\{\ddd\}

double d;
auto i = convert_to<int>(d); // need to specify at least the first arg\end{codeblock}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Template argument deduction \insertcontinuationtext}

  \begin{itemize}
  \item \Cpp{}17 has introduced the possibility to deduce class template
    arguments
  \item Mostly based on constructor calls, which are functions after all
    \begin{itemize}
    \item Constructor Template Argument Deduction (CTAD)
    \end{itemize}
    \begin{codeblock}
template<class F> class Complex \{\ddd\};

Complex d;             // error, cannot deduce
Complex<double> e;     // ok
Complex f\{1.\};         // ok in C++17, Complex<double>
Complex<double> g\{1.\}; // ok
Complex<float> h\{1.\};  // ok, Complex<float>, 1. -> 1.F\end{codeblock}
  \item If CTAD is not available, leverage function template argument deduction
    \begin{codeblock}
template<class F> make_complex(F r, F i) \{
  return Complex<F>(r, i);
\};

auto c = make_complex(1.,2.); // Complex<double>\end{codeblock}
  \end{itemize}

\end{frame}

\begin{frame}{Exercises}

  \begin{itemize}
  \item Write an \code{operator+} that adds two complex numbers of different types

  \item Transform the \code{Rational} class into a class template, where the
    parameter is the type used to represent numerator and denominator. Adapt the
    operators.

    Write a program that instantiates the \code{Rational} class with integral
    types such as \code{int}, \code{long int}, \code{long long int}, \code{short
      int}. Combine objects of those types using the operators.
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Non-type template parameters}
  \begin{itemize}
  \item A class/function template parameter need not be a type
  \item A template parameter can be a value, which must be known at compile time

    \begin{codeblock}<2->{
template<int I> struct C \{ \ddd \};
C<2> c2;
C<3> c3;              // different type
int n; std::cin >> n;
C<n> c4;              // error, n is not a compile-time constant}\end{codeblock}

  \item<3-> The type of the value needs to satisfy certain constraints
  \item<3-> Integral types (e.g. \code{int}, \code{char}, \code{bool}) and
    enumeration types are allowed, other \textit{structural} types (including
    floating-point types) since \Cpp{}20

    \begin{codeblock}<3->{
template<double D> struct F \{ \ddd \}; // ok since C++20}\end{codeblock}

\item<4-> Type and non-type template parameters can be mixed

  \begin{codeblock}<4->{
template<class T, int N> struct array \{ \ddd \};
template<class T, T v> struct integral_constant \{ \ddd \};}\end{codeblock}

  \end{itemize}

\end{frame}

\begin{frame}{The C++ standard library}

  \begin{itemize}
  \item The standard library contains components of general use
    \begin{itemize}
    \item \alert<2>{containers (data structures)}
    \item \alert<2>{algorithms}
    \item strings
    \item input/output
    \item mathematical functions
    \item random numbers
    \item regular expressions
    \item concurrency and parallelism
    \item filesystem
    \item \ldots
    \end{itemize}

  \item The subset containing containers and algorithms is known as STL
    (Standard \alert{\textbf{Template}} Library)
    \begin{itemize}
    \item But templates are everywhere
    \end{itemize}
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Namespaces}

  \begin{itemize}
  \item How can we guarantee that in a program composed of thousands of files,
    written by thousands of people, using third-party libraries, there are no
    conflicts between identifiers?
  \item Namespaces are a mechanism to partition the space of names in a program
    to prevent such conflicts

    \begin{codeblock}
// in <vector>
\alert{namespace std \{}
  template<class T> vector \{ \ddd \};
\alert{\}}

// in <algorithm>
\alert{namespace std \{}
  template<class It, class T> find(It first, It last, T const& v) \{ \ddd \}
\alert{\}}\end{codeblock}

  \item Namespaces can be re-opened, even in other files
  \begin{itemize}
  \item But namespace \code{std} cannot be re-opened by a user, unless
    explicitly allowed by the specification
  \end{itemize}
  \item Namespaces can be nested
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Namespaces \insertcontinuationtext}

  \begin{itemize}

  \item<1-> A \textbf{namespace alias} gives another name to an existing namespace
    \begin{codeblock}
namespace ch = std::chrono;

auto t0 = ch::system_clock::now(); // std::chrono::system_clock::now()\end{codeblock}
  \item<2-> A \textbf{using declaration} makes a namespace symbol visible in the
  current scope
    \begin{codeblock}
using std::string;

string s;\end{codeblock}
  \item<3-> A \textbf{using directive} makes \alert{all} the namespace symbols visible
  in the current scope
    \begin{codeblock}
using namespace std;

string s;\end{codeblock}

  \item<4-> Avoid ``using directives''. They are especially bad in the global scope
    and in header files
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Namespaces \insertcontinuationtext}

  \begin{itemize}
  \item It's good practice to put all entities of a software component into a namespace

    \begin{codeblock}
namespace stats \{

struct Result \{ \ddd \};
class Regression \{ \ddd \};

Result fit(Regression const&);

\}\end{codeblock}

  \item Within a namespace, when using a name declared in that namespace, there is
    no need to namespace-qualify it (i.e. prepending \textit{namespace}\code{::})
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Enumerations}

  \begin{itemize}[<+->]
  \item An \textit{enumeration} is a distinct type with named constants, called
    \textit{enumerators}

  \begin{codeblock}
enum class Operator \{ Plus, Minus, Multiplies, Divides \};\end{codeblock}

  \item When used, an enumerator is specified with the name of the enumeration
    followed by the scope-resolution operator (\code{::})

    \begin{codeblock}
auto op\{Operator::Plus\}; // op is of type Operator\end{codeblock}

  \item An enumeration plays well with \code{switch} statements

    \begin{codeblock}
double compute(Operator op, double left, double right)
\{
  switch (op) \{
    case Operator::Plus:       return left + right;
    case Operator::Minus:      return left - right;
    case Operator::Multiplies: return left * right;
    case Operator::Divides:    \ddd return left / right;
    default: throw std::runtime_error\{"invalid operand"\};
  \}
\}\end{codeblock}

  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Enumerations \insertcontinuationtext}

  \begin{itemize}[<+->]
  \item An enumeration has an integral \textit{underlying type}, by default \code{int}
  \item A different underlying type can be selected
    \begin{codeblock}<.->{
enum class byte : unsigned char \{ \};}\end{codeblock}

    Note that in this case there are no enumerators $\rightarrow$ a way to define a
    new integral type different from the underlying type

  \item By default, an enumerator has the value of the previous enumerator
    incremented by one and the first enumerator has value $0$
  \item An enumerator can be given a value explicitly
    \begin{codeblock}<.->{
enum class Operator \{ Plus = -2, Minus, Multiplies = 42, Divides \};}\end{codeblock}
    The values are respectively $-2$, $-1$, $42$ and $43$.
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Enumerations \insertcontinuationtext}

  \begin{itemize}[<+->]
  \item All values of the underlying type are valid values for the enumeration
    object

    \begin{codeblock}<.->
Operator op\{55\};  // ok\end{codeblock}

  \item Conversions to the underlying type need to be explicit

    \begin{codeblock}<.->
int i\{Operator::Plus\};                     // error
auto i\{static_cast<int>(Operator::Plus)\};  // ok\end{codeblock}

  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Enumerations \insertcontinuationtext}

  \begin{itemize}[<+->]
  \item There is also a less strict version of an enumeration: the
    \textit{unscoped} enumeration
    \begin{codeblock}
enum Operator \{ Plus, Minus, Multiplies, Divides \}; // NB no class\end{codeblock}

  \item The symbols of the enumerators are visible in the enclosing scope
    \begin{itemize}[<.->]
    \item i.e. the enumerators are not specified with the name of the
      enumeration followed by \code{::}
    \end{itemize}

    \begin{codeblock}<.->
Operator op\{Plus\};  // ok, no need to use Operator::
\end{codeblock}

  \item The conversion to the underlying type is implicit
    \begin{codeblock}<.->
int i\{Plus\};  // ok\end{codeblock}

  \item Prefer the scoped enumeration

  \end{itemize}

\end{frame}

\begin{frame}{Hexadecimal notation}

  \begin{columns}
    \begin{column}{.75\textwidth}
      \begin{itemize}
      \item<1-> Numbers in hexadecimal notation are represented in base sixteen
      \item<2-> Each digit has a value between zero and fifteen (included)
      \item<2-> Sixteen symbols are needed for the digits
        \begin{itemize}
        \item 0 ... 9, A, B, C, D, E, F (also lowercase)
        \end{itemize}
      \item<3-> In C++ numeric literals (i.e. constants) can be expressed in hexadecimal
        notation, prepending \code{0x} (or \code{0X}) to the hexadecimal representation
        \begin{itemize}
        \item \code{0x9 == 9}, \code{0xA == 10}, \code{0x10 == 16}
        \end{itemize}
      \item<3-> Easy conversion between hex and binary representation: each hex digit
        corresponds to four bits
      \item<4-> Hex literals are typically used to represent raw contents of memory or
        memory addresses
      \end{itemize}

    \end{column}

    \begin{column}{.25\textwidth}
      \visible<3->{
        \small{
          \begin{tabular}[t]{|r|r|r|}
            Hex & Dec & Bin \\
            \hline
            0 &  0 & 0000 \\
            1 &  1 & 0001 \\
            2 &  2 & 0010 \\
            3 &  3 & 0011 \\
            4 &  4 & 0100 \\
            5 &  5 & 0101 \\
            6 &  6 & 0110 \\
            7 &  7 & 0111 \\
            8 &  8 & 1000 \\
            9 &  9 & 1001 \\
            A & 10 & 1010 \\
            B & 11 & 1011 \\
            C & 12 & 1100 \\
            D & 13 & 1101 \\
            E & 14 & 1110 \\
            F & 15 & 1111
          \end{tabular}
        }
      }
    \end{column}
  \end{columns}

\end{frame}

\begin{frame}[fragile]{Pointers}

  Where in memory does a given object reside?

  \begin{tikzpicture}[
      mem/.style={
        node font=\ttfamily\scriptsize,
        minimum height=.5cm,
      },
      location/.style={
        mem,
        draw=black!50,
        minimum width=1.2cm,
        fill=green!20!white,
      },
      address/.style={
        mem,
        draw=black,
        minimum width=.3cm,
        densely dotted,
      },
      every node/.style={
        mem,
      },
      anchor=south west,
      node distance=0,
    ]

    \visible<2->{\node (memory) at (0,0) [mem, draw=black!50, minimum width=.9\textwidth] {};}
    \visible<3->{\node (begin mem) [address, right=of memory.west, "0x0000" above] {};}
    \visible<3->{\node (end mem) [address, left=of memory.east, "0xffff" above] {};}

    \visible<6-8>{\node (pp) at (1.2,0) [location, "pp" below] {\alert<6>{0xbad0}};}
    \visible<6-8>{\node (addr pp) [address, right=of pp.west, "0xaa04" above] {};}

    \visible<2-8>{\node (i) [location, right=0.5 of pp, "i" below,] {4321};}
    \visible<3-8>{\node (addr i) [address, right=of i.west, "\alert<5>{0xab00}" above] {};}

    \visible<5->{\node (p) [location, right=0.5 of i, "p" below] {
        \alt<-6>
            {\alert<5>{0xab00}}
            {\alt<-11>
              {\alert<7-8>{0xcd00}}
              {\alert<12>{\textit{null}}}}};
    }
    \visible<5->{\node (addr p) [address, right=of p.west, "\alert<6>{0xbad0}" above] {};}

    \visible<2->{\node (j) [location, right=0.5 of p, "j" below,] {
        \alt<-9>
            {1234}
            {\alt<10>
              {\alert<10>{5678}}
              {\alert<11>{5679}}}};
    }
    \visible<3->{\node (addr j) [address, right=of j.west, "\alert<7>{0xcd00}" above] {};}

    \visible<8>{\node (q) [location, right=0.5 of j, "q" below,] {\alert<8>{0xcd00}};}
    \visible<8>{\node (addr q) [address, right=of q.west, "0xcb80" above] {};}

    \visible<9->{\node (k) at (1.5,0) [location, "k" below,] {\alert<9>{1234}};}
    \visible<9->{\node (addr k) [address, right=of k.west, "0xaacc" above] {};}

    \draw<5-6>[{Circle[length=2pt]}-Stealth,opacity=.6] ([yshift=.1cm]p.center) .. controls +(-1,.5) .. (addr i.north);
    \draw<7-11>[{Circle[length=2pt]}-Stealth,opacity=.6] ([yshift=.1cm]p.center) .. controls +(1,.5) .. (addr j.north);
    \draw<6-8>[{Circle[length=2pt]}-Stealth,opacity=.6] ([yshift=-.1cm]pp.center) .. controls +(2,-.5) .. (addr p.south);
    \draw<8>[{Circle[length=2pt]}-Stealth,opacity=.6] ([yshift=.1cm]q.center) .. controls +(-1,.5) .. (addr j.north);

  \end{tikzpicture}

  \begin{codeblock}<4->{
\visible<4->{std::cout <{}< \alert<4>{&}i;  // 0xab00, \alert<4>{address-of operator}}
\visible<4->{std::cout <{}< \alert<4>{&}j;  // 0xcd00}
\visible<5->{int\alert<5>{*} p = &i;      // \alert<5>{pointer declarator}}
\visible<6->{std::cout <{}< &p;  // 0xbad0}
\visible<6->{int\alert<5>{**} pp = &p;    // &p is of type int**}
\visible<7->{p = &j;}
\visible<8->{int* q = p;       // p and q point to the same object}}\end{codeblock}

  \begin{codeblock}<9->{
\visible<9->{std::cout <{}< \alert<9->{*}p; // 1234, \alert<9>{dereference} operator}
\visible<9->{int k = \alert<9->{*}p;}
\visible<10->{\alert<9->{*}p = 5678;}
\visible<11->{++(\alert<9->{*}p);}
\visible<12->{p = nullptr;}
\visible<13->{\alert<9->{*}p; // \alert{undefined behavior}}}\end{codeblock}

\visible<5->{Note that \code{int*} is a type by
  itself}\visible<6->{ and so is \code{int**}}

\end{frame}

\begin{frame}[fragile]{Pointers \insertcontinuationtext}

  \begin{itemize}
  \item<1-> \textit{address-of} operator: \alert{\code{\&}}
    \begin{itemize}
    \item Given an object it returns its address in memory
    \end{itemize}
  \item<2-> \textit{dereference} operator: \alert{\code{*}}
    \begin{itemize}
    \item Given a pointer to an object it returns a reference to that object
    \end{itemize}
  \item<3-> \textit{structure dereference} operator: \alert{\code{->}}
    \begin{itemize}
    \item Given a pointer to an object of class/struct type, it returns a
      reference to a member of that object
    \end{itemize}
    \begin{codeblock}
struct S \{
  int n;
  void f();
\};

S q\{\ddd\};
S* p = &q;
p->n;        // equivalent to (*p).n
p->f();      // equivalent to (*p).f()\end{codeblock}

  \end{itemize}
\end{frame}

\begin{frame}[fragile]{The \code{this} pointer}

  Within the body of a member function of a class \code{T}, the keyword
  \code{this}
  \begin{itemize}
  \item is a pointer of type \code{T*} (or \code{T const*} if the method is
    \code{const})
  \item points to the object for which the method was called
  \end{itemize}

\begin{codeblock}<2->{
struct Foo \{
  void bar() \{
    ... this ...;\uncover<4->{ // address of \alt<4>{alfa (i.e. \&alfa)}{beta (i.e. \&beta)}}
  \}
\};

\uncover<3->{Foo alfa, beta;}
\uncover<4->{alfa.bar();}
\uncover<5>{beta.bar();}}\end{codeblock}

    \begin{codeblock}<6->{
class Complex \{
  \ddd
  Complex\alert{&} operator+=(Complex const& rhs) \{
    r += rhs.r; i += rhs.i;
    return \alert{*this};
  \}
\};}\end{codeblock}

\end{frame}

\begin{frame}[fragile]{Nested class}
  \begin{itemize}

  \item A class can be defined within the definition of another class
    \begin{itemize}
    \item in either the public or private section
    \end{itemize}

    \begin{codeblock}
class Regression \{
  \ddd
  \alert{class Result \{ \ddd \};}
  Result fit() const \{ \ddd \}
\};

Regression reg;
\ddd
Regression::Result result = reg.fit();\end{codeblock}

  \item<2-> The nested class can access the private members of the outer class
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Type alias}

  \begin{itemize}
  \item A type alias is another name for an existing type

  \begin{codeblock}
using Length = double;
typedef double Length; // equivalent, old alternative

Length len = 1.; // len is of type double\end{codeblock}

  \item<2-> A type alias does \textbf{not} introduce a new type

    \begin{codeblock}<2->{
void walk(double) \{ \ddd \}
void walk(Length) \{ \ddd \} // error, redefinition of walk}\end{codeblock}

  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Type alias \insertcontinuationtext}

  \begin{itemize}
  \item Type aliases are often used to declare types within a class

    \begin{codeblock}
class FitResult \{ \ddd \};

class Regression \{
  \ddd
 public:
  \alert{using Result = FitResult;}
  Result fit() const \{ \ddd \}
\};

Regression::Result result = reg.fit(); // result is of type FitResult\end{codeblock}

  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Structured binding (C++17)}
  \begin{itemize}
  \item A \textit{structured binding} declaration declares multiple variables
    and initializes them from values of struct members (and other entities,
    following a certain \textit{protocol})
    \begin{codeblock}
struct Point \{
  double x;
  double y;
\};

Point p\{1.,2.\};
auto [a, b] = p;
std::cout << a << \upquote{ } << b; // print 1 2\end{codeblock}

  \item<2-> The variables can be declared as (const) references to the struct members
    \begin{codeblock}
Point p\{1.,2.\};
auto& [a, b] = p; // a is a ref to p.x, b is a ref to p.y
a = 3.;
b = 4.;
std::cout << p.x << \upquote{ } << p.y; // print 3 4\end{codeblock}

  \end{itemize}
\end{frame}

\begin{frame}{The C++ standard library}

  \begin{itemize}
  \item The standard library contains components of general use
    \begin{itemize}[<.->]
    \item \alert<2>{containers (data structures)}
    \item \alert<2>{algorithms}
    \item strings
    \item input/output
    \item mathematical functions
    \item random numbers
    \item regular expressions
    \item concurrency and parallelism
    \item filesystem
    \item \ldots
    \end{itemize}

  \item<2-> The subset containing containers and algorithms is known as STL
    (Standard Template Library)
  \end{itemize}

\end{frame}

\begin{frame}{Containers of objects}
  \begin{itemize}
  \item A program often needs to manage collections of objects
    \begin{itemize}
    \item e.g. a string of characters, a dictionary of words, a list of
      particles, a matrix, \ldots
    \end{itemize}
  \item<2-> A \textit{container} is an object that contains other objects
  \item<2-> The C++ Standard Library provides a few container classes
    \begin{itemize}[<.->]
    \item implemented as class templates
    \item different characteristics and operations, some common traits
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{\code{std::vector<T>}}

  \alert{Dynamic} container of elements of type \code{T}
  \begin{itemize}
  \item its size can vary at runtime
  \item layout is contiguous in memory
  \item container you should use by default
  \item<4-> be careful with initialization: \code{\{\}} vs \code{()}
    \begin{itemize}
    \item check if there is a constructor that takes an
      \code{std::initializer_list}
    \end{itemize}
  \end{itemize}

  \begin{codeblock}<2->{
#include <vector>

std::vector<int> a;      // empty vector of ints
\visible<3->{std::vector<int> b\{2\};   // one element, initialized to 2}
\visible<4->{std::vector<int> c(2);   // two elements (!), value-initialized (0 for int)}
\visible<5->{std::vector<int> d\{2,1\}; // two elements, initialized to 2 and 1
std::vector<int> e(2,1); // two elements, both initialized to 1}

\visible<6->{
auto f = b; // make a copy, f and b are two distinct objects
f == b;     // true}}\end{codeblock}

\end{frame}

\begin{frame}[fragile]{\code{std::vector<T>} \insertcontinuationtext}

  \begin{itemize}
  \item The \code{size} method gives the number of elements in the vector
  \item The \code{empty} method tells if the vector is empty
  \item \code{operator[]} gives access to the $i^{th}$ element
  \end{itemize}

  \begin{codeblock}
std::vector<int> vec\{1,2,3\}; // \{4,2,7\}

assert(!vec.empty());
std::cout << vec.size(); // print 3
vec[1] = 5;              \visible<2->{// vec is now \{4,5,7\}}
std::cout << vec[1];     // print 5\end{codeblock}

  \visible<3->{
    \begin{center}
      \huge\alert{Counting starts from $0$!}
    \end{center}
  }

  \begin{codeblock}<3->{
vec[0];            // first element
vec[1];            // second element
vec[vec.size()-1]; // vec[2], third and last element
vec[vec.size()];   // vec[3], element doesn\textquotesingle{}t exist, undefined behaviour!}\end{codeblock}

\end{frame}

\begin{frame}[fragile]{\code{std::vector<T>} \insertcontinuationtext}
  \begin{itemize}
  \item The \code{push_back} method adds an element at the end of the vector
  \end{itemize}

  \begin{codeblock}<2->{
vec.push_back(-2);       // vec is now \{4,5,7,-2\}
vec.push_back(0);        // vec is now \{4,5,7,-2,0\}
std::cout << vec.size(); // print 5}\end{codeblock}

    \begin{codeblock}<3->{
// fill a vector with numbers read from standard input
std::vector<double> v;
for (double d; std::cin >> d; ) \{
  v.push_back(d);
\}}\end{codeblock}

\end{frame}

\begin{frame}[fragile]{Iterators and ranges}
  \begin{itemize}
  \item An \alert{iterator} is an object that indicates a position within a
    \alert{range}
    \begin{itemize}
    \item A container, such as a vector, is a range
    \end{itemize}
  \item<2-> In fact, a pair of iterators [\textit{first}, \textit{last})
    represents a range
    \begin{itemize}
    \item the range is \textit{half-open}
      \begin{itemize}
      \item \textit{first} points to the first element of the range
      \item \textit{last} points to \textbf{one past} the last element of the
        range
      \end{itemize}
    \item \textit{first} \code{==} \textit{last} means the range is empty
    \end{itemize}

  \begin{tikzpicture}[
    anchor=south west,
    node distance=0,
    ]
    \node at (0,0) [memory] {};

    \node at (2.9,-0.1) [
        rectangle,
        fill=green!10!white,
        draw=black!40,
        minimum width=3.2cm,
        minimum height=0.7cm,
      ] {};
    \node (a0) at (3,0) [word] {123};
    \node (a1) [word, right=of a0] {456};
    \node (a2) [word, right=of a1] {789};
    \node (a3) [dotted word, right=of a2] {};
    \node (first) [word, below=.5cm of a0, label={180:\textit{\scriptsize first}}] {};
    \node (last) [word, below=.5cm of a3, label={180:\textit{\scriptsize last}}] {};
    \draw[->] (first.north) -- (a0.south);
    \draw[->] (last.north) --  (a3.south);

  \end{tikzpicture}

  \item<3-> Ranges are typically obtained from containers calling methods
    \code{begin} and \code{end}
    \begin{codeblock}
std::vector<int> v \{\ddd\};
auto first = v.begin(); // std::vector<int>::iterator
auto last = v.end();    // std::vector<int>::iterator\end{codeblock}
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Operations on iterators}

  \begin{itemize}
  \item Syntactically, operations on iterators are inspired by pointers
  \item There is a minimal set of operations supported by an iterator \code{it}

  \item \code{*it} gives access to the element pointed to by \code{it}

    \begin{codeblock}
std::vector<int> v \{1,2,3\};
auto it = v.begin();
std::cout << *it; // print 1
*it = 4;          // v is now \{4,2,3\}\end{codeblock}

      \begin{codeblock}
auto it = v.end();

*it; // undefined behaviour, it doesn\textquotesingle{}t point inside the range\end{codeblock}

  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Operations on iterators \insertcontinuationtext}

  \begin{itemize}
  \item \code{it->\textit{member}} gives access to a member (data or
    function) of the element pointed to by \code{it}
    \begin{itemize}
    \item equivalent to \code{(*it).\textit{member}}, note the parenthesis
    \end{itemize}

    \begin{columns}
      \begin{column}{.7\textwidth}
        \begin{codeblock}
std::vector<Point> v \{Point\{1,2\}, Point\{3,4\}\};
auto it = v.begin();
std::cout << (*it).x; // print 1
std::cout << it->x;   // equivalent\end{codeblock}
      \end{column}
      \begin{column}{.2\textwidth}
        \begin{codeblock}
struct Point \{
  double x;
  double y;
\};\end{codeblock}
      \end{column}
    \end{columns}

    \begin{codeblock}
std::vector<std::string> v \{"hello", "world"\};
auto itv = v.begin();    // itv points to the first string in the vector
auto its = itv->begin(); // its points to the first character
                         //   of the first string (\upquote{h});
                         //   a string is a container of characters\end{codeblock}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Operations on iterators \insertcontinuationtext}

  \begin{itemize}
  \item \code{++it} advances \code{it} so that it points to the next element in
    the range
    \begin{codeblock}
std::vector<int> v \{123, 456, 789\};
auto first = v.begin();
auto last = v.end();
std::cout << *first; // print 123
\visible<2->{++first;}
\visible<2->{std::cout << *first; // print 456}\end{codeblock}

  \end{itemize}

  \begin{tikzpicture}[
    anchor=south west,
    node distance=0,
    ]
    \node at (0,0) [memory] {};

    \node at (2.9,-0.1) [
    rectangle,
    fill=green!10!white,
    draw=black!40,
    minimum width=3.2cm,
    minimum height=0.7cm,
    ] {};
    \node (a0) at (3,0) [word] {123};
    \node (a1) [word, right=of a0] {456};
    \node (a2) [word, right=of a1] {789};
    \node (a3) [dotted word, right=of a2] {};
    \node (first) [word, below=.5cm of a0, label={180:\textit{\scriptsize first}}] {};
    \node (last) [word, below=.5cm of a3, label={180:\textit{\scriptsize last}}] {};
    \visible<1>{\draw[->] (first.north) -- (a0.south);}
    \visible<2->{\draw[->] (first.north) -- (a1.south);}
    \draw[->] (last.north) --  (a3.south);
  \end{tikzpicture}

\end{frame}

\begin{frame}[fragile]{Operations on iterators \insertcontinuationtext}
  \begin{itemize}
  \item<1-> \code{it1 == it2} (\code{it1 != it2}) tells if \code{it1} and
    \code{it2} point to the same element (different elements) of the range
    \begin{codeblock}
++first; ++first;
first == last;  // true\end{codeblock}
  \item<2-> Other operations (\code{--it}, \code{it~+~n}, \code{it~+=~n},
    \code{it~<~it2}, \ldots) may be supported, depending on the underlying range
    \begin{itemize}
    \item vector iterators support them all
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Example: add all elements of a vector\\(Iteration on a container)}

  \begin{codeblock}
std::vector<int> c \{ \ddd \};\end{codeblock}

  \begin{codeblock}<2->{
auto sum = 0;
for (int i = 0, n = c.size(); i != n; ++i) \{
  auto const& v = c[i];
  sum += v;
\}}\end{codeblock}

  \begin{codeblock}<3->{
auto sum = 0;
for (auto it = c.begin(), end = c.end(); it != end; ++it) \{
  auto const& v = *it;
  sum += v;
\}}\end{codeblock}

  \begin{codeblock}<4->{
auto sum = 0;
for (auto const& v : c) \{
  sum += v;
\}}\end{codeblock}

  \begin{codeblock}<5->{
auto sum = std::accumulate(c.begin(), c.end(), 0);} // algorithm\end{codeblock}

\end{frame}

\begin{frame}[fragile]{\code{std::vector<T>} \insertcontinuationtext}

  \begin{itemize}
  \item The \code{erase} method removes the element pointed to by the iterator
    passed as argument (must not be \code{end()})
    \begin{codeblock}
// remove the central element
auto it = v.begin() + v.size() / 2; // iterator to the middle element
v.erase(it);                        // size decreased by 1\end{codeblock}

  \item<2-> The \code{erase} method can remove a range, passing two iterators
    \begin{codeblock}<2->{
// erase the 2nd half of the vector
auto it = v.begin() + v.size() / 2; // iterator to the middle element
v.erase(it, v.end());               // size ~halved here}\end{codeblock}

\item<3-> In general, iterators pointing to erased elements are not valid anymore
  \begin{itemize}
  \item For a vector, iterators pointing to elements following the erased one are
    also invalidated, including the end iterator
  \end{itemize}
  \begin{codeblock}
v.erase(it);
*it;       // undefined behaviour (UB)
++it;      // UB, be careful in loops
it = \ddd;  // ok\end{codeblock}
\end{itemize}

\end{frame}

\begin{frame}[fragile]{\code{std::vector<T>} \insertcontinuationtext}

  \begin{itemize}
  \item The \code{insert} method inserts an element before the position
    indicated by an iterator
    \begin{codeblock}
// insert the value 42 in the middle of the vector
auto it = v.begin() + v.size() / 2;
v.insert(it, 42);                   // size increased by 1\end{codeblock}

  \item<2-> Other overloads of \code{insert} are available, see reference
  \item<3-> Existing iterators pointing to elements after the insertion position
    are invalidated
    \begin{itemize}
    \item If a memory reallocation occurs (see later), all existing iterators
      pointing into the vector are invalidated
    \end{itemize}
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{\code{std::array<T, N>}}
  \begin{columns}
    \begin{column}{.6\textwidth}

  Container of \code{N} elements of type \code{T}
  \begin{itemize}
  \item \code{N} known at compile time
  \item layout is contiguous in memory
  \end{itemize}

\begin{codeblock}<2->{
#include <array>

// 2 ints, uninitialized
std::array<int,2> a;

// 2 ints, initialized to 1 and 2
std::array<int,2> b\{1,2\};

// 2 ints, value-initialized (0 for int)
std::array<int,2> c\{\};

// 2 ints, initialized to 1 and 0
std::array<int,2> d\{1\};

\visible<4->{// make a copy
auto e = b;  // std::array<int,2>
assert(e == b);}}\end{codeblock}

    \end{column}

    \begin{column}{.4\textwidth}

      \begin{tikzpicture}[
        mem/.style={
          minimum width=2cm,
          inner sep=0pt,
          outer sep=0pt,
          draw=black
        },
        frame/.style={
          minimum width=2cm,
          inner sep=0pt,
          outer sep=0pt,
          draw=black,
          thick,
          fill=green!50!white
        },
        var/.style={
          node font=\ttfamily\scriptsize,
          minimum height=.5cm,
          minimum width=2cm,
          draw=black,
          fill=green!30!white,
          inner sep=0pt,
          outer sep=0pt
        },
        array/.style={
          node font=\ttfamily\scriptsize,
          minimum height=1.2cm,
          minimum width=2.2cm,
          draw=black!40,
          fill=green!10!white,
          inner sep=0pt,
          outer sep=0pt
        },
        anchor=south west
        ]
        \visible<3->{
          \node (stack) at (0,0) [
          mem,
          minimum height=6.5cm
          ] {};
          \node (main) [
          frame,
          minimum height=3.5cm,
          below=3ex of stack.north
          ] {};
          \node (b) [
          array,
          below=3ex of main.north,
          label={180:\scriptsize\tt b}
          ] {};
          \node (b0) [
          var,
          above=.1cm of b.south,
          ] {\tiny 1};
          \node (b1) [
          var,
          above=0pt of b0.north,
          ] {\tiny 2};
        }
        \visible<4->{
          \node (e) [
          array,
          above=3ex of main.south,
          label={180:\scriptsize\tt e}
          ] {};
          \node (e0) [
          var,
          above=.1cm of e.south,
          ] {\tiny 1};
          \node (e1) [
          var,
          above=0pt of e0.north,
          ] {\tiny 2};
        }
      \end{tikzpicture}
    \end{column}

  \end{columns}

\end{frame}

\begin{frame}[fragile]{\code{std::array<T, N>} \insertcontinuationtext}

  \begin{itemize}
  \item The \code{size} method gives the number of elements in the array (which
    corresponds to \code{N})
  \item \code{operator[]} gives access to the $i^{th}$ element
    \begin{codeblock}
int const M = 4;
std::array<int, M> arr\{1,2\}; // \{1,2,0,0\}

std::cout << arr.size(); // print 4
arr[1] = 3;              // arr is now \{1,3,0,0\}
std::cout << arr[1];     // print 3\end{codeblock}

  \item \code{begin}, \code{end}, \code{empty}, \code{front}, \code{back} methods
  \item No \code{push_back} or \code{insert}, the size is fixed.
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Type aliases \insertcontinuationtext}

  \begin{itemize}
  \item Type aliases can be templates
  \end{itemize}

  \begin{codeblock}
template<class \alert{T}> using Array3 = std::array<\alert{T}, 3>; // array of 3 T's

Array3<\alert{double}> a; // a is std::array<double, 3>\end{codeblock}

\begin{codeblock}
template<int \alert{N}> using ArrayOfBytes = std::array<std::byte, \alert{N}>; // array of N bytes

ArrayOfBytes<\alert{16}> b; // b is std::array<std::byte, 16>\end{codeblock}
\end{frame}

\begin{frame}[fragile]{Algorithms}

  \begin{itemize}
  \item Generic functions that operate on \alert{ranges} of objects
  \item Implemented as function templates
  \end{itemize}

  \begin{itemize}
  \item<2-> Sum all the elements of a container \code{cont}
    \begin{codeblock}
auto sum = 0;
for (int i = 0; i != cont.size(); ++i) \{
  sum += cont[i];
\}\end{codeblock}

    \begin{codeblock}<3->{
auto sum = std::accumulate(cont.begin(), cont.end(), 0); // better}\end{codeblock}

  \item<4-> Find an element equal to \code{val} in a container \code{cont}
    \begin{codeblock}
auto it = cont.begin();
auto const end = cont.end();
for (; it != end; ++it) \{
  if (*it == val) \{
    break;
  \}
\}\end{codeblock}

    \begin{codeblock}<5->{
auto it = std::find(cont.begin(), cont.end(), val); // better}\end{codeblock}

  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Generic programming}

  \begin{itemize}
  \item A style of programming in which \alert{algorithms} are written
    in terms of \alert{concepts}

    \begin{codeblock}
template<class InputIterator, class Tp>
Tp \textbf{accumulate}(InputIterator first, InputIterator last, Tp init)
\{
    for (; first \alert{!=} last; \alert{++}first)
        init \alert{=} init \alert{+} \alert{*}first;
    return init;
\}\end{codeblock}

  \begin{codeblock}
template <class Iterator, class T>
Iterator \textbf{find}(Iterator first, Iterator last, const T\& value)
\{
  for (; first \alert{!=} last; \alert{++}first)
    if (\alert{*}first \alert{==} value) break;
  return first;
\}\end{codeblock}

  \item A concept is a set of requirements that a type needs to satisfy
    \begin{itemize}
    \item e.g. supported expressions, nested typedefs, memory layout, \ldots
    \end{itemize}
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Hierarchy of iterators}

  \begin{columns}[T]
    \begin{column}{.55\textwidth}
      \begin{codeblock}<2->{\tiny
// InputIterator (find)
while (first \alert{!=} last \&\& !(\alert{*}first == value)) \alert{++}first;}\end{codeblock}

      \begin{codeblock}<3->{\tiny
// OutputIterator (generate_n)
for (; n > 0; \alert{++}first, --n) \alert{*}first \alert{=} gen();}\end{codeblock}

      \begin{codeblock}<4->{\tiny
// ForwardIterator (generate)
for (; first \alert{!=} last; \alert{++}first) \alert{*}first \alert{=} gen();}\end{codeblock}

      \begin{codeblock}<4->{\tiny
// ForwardIterator (adjacent_find)
auto i = \alert{first};
while (\alert{++i} != last) \ddd}\end{codeblock}

      \begin{codeblock}<5->{\tiny
// BidirectionalIterator (reverse)
if (first == \alert{--}last) break;}\end{codeblock}

      \begin{codeblock}<6->{\tiny
// RandomAccessIterator (reverse)
for (; first \alert{<} --last; ++first) \ddd}\end{codeblock}
    \end{column}

    \begin{column}{.45\textwidth}
      \begin{tikzpicture}
        [auto,
        box/.style = {rectangle, draw=black, node font=\scriptsize, align=flush center},
        line/.style      = {draw}]
        \matrix [column sep=-15mm,row sep=8mm,ampersand replacement=\&]
        {
          \visible<2->{        \node [box] (input) {InputIterator\\{\tiny read, increment, comparison}};} \\
          \& \& \visible<3->{\node [box] (output) {OutputIterator\\{\tiny write, increment}};} \\
          \& \visible<4->{\node [box] (forward) {ForwardIterator\\{\tiny multiple passes}};} \\
          \& \visible<5->{\node [box] (bidirectional) {BidirectionalIterator\\{\tiny decrement}};} \\
          \& \visible<6->{\node [box] (randomaccess) {RandomAccessIterator\\{\tiny random access}};} \\
        };
        \begin{scope}[every path/.style=line]
          \visible<4->{\path (input)  -- (forward);}
          \visible<4->{\path (output)  -- (forward);}
          \visible<5->{\path (forward) -- (bidirectional);}
          \visible<6->{\path (bidirectional) -- (randomaccess);}
        \end{scope}
      \end{tikzpicture}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}{Examples of algorithms}

  \begin{description}[<+->]
  \item[Non-modifying] \code{all_of any_of for_each count count_if mismatch
      equal find find_if adjacent_find search \ldots}
  \item[Modifying] \code{copy copy_if fill generate transform remove replace
      swap reverse rotate shuffle sample unique \ldots}
  \item[Partitioning] \code{partition stable_partition \ldots}
  \item[Sorting] \code{sort partial_sort nth_element \ldots }
  \item[Set] \code{includes set_union set_intersection \ldots}
  \item[Min/Max] \code{min max minmax clamp \ldots}
  \item[Comparison] \code{equal lexicographical_compare \ldots}
  \item[Numeric] \code{iota accumulate inner_product partial_sum
      adjacent_difference reduce \ldots}
  \item \ldots
  \end{description}
\end{frame}

\begin{frame}[fragile]{Algorithms in action}

  \begin{codeblock}
std::array a = \{ 23, 54, 41, 0, 18 \};

// sort the array in ascending order
std::sort(std::begin(a), std::end(a));

// sum up the array elements, initializing the sum to 0
auto s = std::accumulate(std::begin(a), std::end(a), 0);

// append the partial sums of the array elements into a vector
std::vector<int> v;
std::partial\_sum(std::begin(a), std::end(a), std::back\_inserter(v));

auto p = std::inner_product(std::begin(a), std::end(a), std::begin(v), 0);

// find the first element with value 42, if existing
auto it = std::find(std::begin(v), std::end(v), 42);\end{codeblock}

\end{frame}

\begin{frame}[fragile]{Why using standard algorithms}

  \begin{itemize}[<+->]
  \item They are correct
  \item They express intent more clearly than a raw \code{for}/\code{while} loop
  \item They are efficient
    \begin{itemize}
    \item They give computational complexity guarantees
    \item How fast do they run? how much additional memory do they need?
    \end{itemize}
  \item They enable \textit{parallelism for the masses}
    \begin{itemize}[<.->]
    \item C++17
    \end{itemize}
  \end{itemize}

  \begin{codeblock}<+->{
#include <execution>

std::vector<int> v = \ddd;

std::sort(\alert{std::execution::par}, v.begin(), v.end());

auto it = std::find(\alert{std::execution::par}, v.begin(), v.end(), 123);
}\end{codeblock}

\end{frame}

\begin{frame}{Computational complexity}

  \begin{itemize}
  \item<1-> A measure of how many resources a computation will need for a given
    input size
    \begin{itemize}
    \item Typically the resource is time but can be space (memory)
    \item For example: how many comparisons does the sort algorithm do for a
      range of one million elements?
    \end{itemize}
  \item<1-> Of typical interest are the average case and the worst case
  \item<2-> The complexity is a function $f$ of the input size $n$, but usually only
    the asymptotic behaviour is given
    \begin{itemize}
    \item Big-O notation
    \item $\mathcal{O}(g(n))$ means that, for a large $n$,
      $f \le cg(n)$, for some constant $c$
    \item Note how constant factors don't matter in big-O notation
    \end{itemize}
  \item<3-> For example
    \begin{itemize}
    \item \code{std::vector<T>::push_back} is (amortized) $\mathcal{O}(1)$
    \item \code{std::binary_search} is $\mathcal{O}(\log{}n)$
    \item \code{std::find} is $\mathcal{O}(n)$
    \item \code{std::sort} is $\mathcal{O}(n\log{}n)$
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Computational complexity \insertcontinuationtext}
  \begin{center}
    \includegraphics[height=.8\textheight]{images/O}
    \par
    \tiny{Cmglee / CC BY-SA (https://creativecommons.org/licenses/by-sa/4.0)}
  \end{center}
\end{frame}

\begin{frame}[fragile]{Functions}

  \begin{itemize}
  \item A function associates a sequence of statements (the function
    \textit{body}) with a name and a list of zero or more parameters

  \item A function may return a value
  \item Multiple functions can have the same name $\rightarrow$
    \textit{overloading}
    \begin{itemize}
    \item different parameter lists
    \end{itemize}

  \item<2-> A function returning a \code{bool} is called a \textit{predicate}
    \begin{codeblock}
bool less(int n, int m) \{ return n < m; \}\end{codeblock}

  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Algorithms and functions}

  \begin{codeblock}{\tiny
template <class Iterator, class T>
Iterator find(Iterator first, Iterator last, \alert{const T\& value})
\{
  for (; first != last; ++first)
    if (\alert{*first == value})
      break;
  return first;
\}

auto it = find(v.begin(), v.end(), 42);}\end{codeblock}

  \begin{codeblock}<2->
template <class Iterator, class Predicate>
Iterator find_if(Iterator first, Iterator last, \alert{Predicate pred})
\{
  for (; first != last; ++first)
    if (\alert{pred(*first)})         // unary predicate
      break;
  return first;
\}

\uncover<3->{bool lt42(int n) \{ return n < 42; \}}

\uncover<4->{auto it = find_if(v.begin(), v.end(), lt42);}
\uncover<6->{auto it = find_if(v.begin(), v.end(), [](int n) \{ return n < 42; \} );}\end{codeblock}

\uncover<5->{Some algorithms are customizable passing a function}
\end{frame}

\begin{frame}[fragile]{Function objects}

  A mechanism to define \textit{something-callable-like-a-function}
  \begin{itemize}
  \item<4-> A class with an \texttt{operator()}
  \end{itemize}

  \begin{columns}[t]

    \begin{column}{.5\textwidth}

      \begin{codeblock}<2->{
\invisible{struct LessThan42 \{}
auto \alert<2,4>{lt42}(int n)
\{
  return n < 42;
\}

\invisible{
LessThan42 lt42\{\};}
auto b = \alert<2,7>{lt42(}32\alert<2,7>{)}; // true

\uncover<3->{vector v\{61,32,51\};
auto it = find_if(
    begin(v), end(v),
    \alert<3,8>{lt42}
); // *it == 32}}\end{codeblock}

    \end{column}

    \begin{column}{.5\textwidth}

      \begin{codeblock}<4->{
\alert<4>{struct LessThan42 \{}
  auto \alert<4>{operator()}(int n) \alert<4>{const}
  \{
    return n < 42;
  \}
\alert<4>{\};}

\uncover<5->{\alt<5>{LessThan42 lt42\{\};}{auto lt42 = LessThan42\{\};}}
\uncover<7->{auto b = \alert<7>{lt42(}32\alert<7>{)}; // true}

\uncover<8,9>{vector v\{61,32,51\};
auto it = find_if(
    begin(v), end(v),
    \alert{\alt<8>{lt42}{LessThan42\{\}}}
); // *it == 32}}\end{codeblock}

    \end{column}
  \end{columns}
\end{frame}

\begin{frame}[fragile]{Function objects \insertcontinuationtext}
  A function object, being the instance of a class, can have state
  \begin{codeblock}<2->{
class LessThan \{
  \alert<2>{int m\_;}
 public:
  explicit \alert<2>{LessThan(int m) : m\_\{m\} \{\}}
  auto operator()(int n) const \{
    return n < m_;
  \}
\};

\uncover<3->{LessThan lt42\{42\};
auto b1 = \alt<-5>{lt42}{\alert<6>{LessThan\{42\}}}(32); // true}

\uncover<4->{LessThan lt24\{24\};
auto b2 = \alt<-5>{lt24}{\alert<6>{LessThan\{24\}}}(32); // false}

\uncover<5->{vector v\{61,32,51\};
auto i1 = find_if(\ldots, \alt<-5>{lt42}{\alert<6>{LessThan\{42\}}}); // *i1 == 32
auto i2 = find_if(\ldots, \alt<-5>{lt24}{\alert<6>{LessThan\{24\}}}); // i2 == end, i.e. not found}}\end{codeblock}

  \uncover<6>{}

\end{frame}

\begin{frame}[fragile]{Function objects \insertcontinuationtext}
  An example from the standard library

  \begin{codeblock}
#include <random>

// random bit generator
std::default_random_engine gen;

// generate N 32-bit unsigned integer numbers
for (int n = 0; n != N; ++n) \{
  std::cout <{}< \alert{gen()} <{}< \bslashn;
\}

// generate N floats distributed normally (mean: 0., stddev: 1.)
std::normal\_distribution<float> dist;
for (int n = 0; n != N; ++n) \{
  std::cout <{}< \alert{dist(gen)} <{}< \bslashn;
\}

// generate N ints distributed uniformly between 1 and 6 included
std::uniform\_int\_distribution<> roll\_dice(1, 6);
for (int n = 0; n != N; ++n) \{
  std::cout <{}< \alert{roll\_dice(gen)} <{}< \bslashn;
\}\end{codeblock}

\end{frame}

\begin{frame}[fragile]{Lambda expression}

  \begin{itemize}
  \item A concise way to create an unnamed function object
  \item Useful to pass actions/callbacks to algorithms, threads, frameworks,
    \ldots
  \end{itemize}

  \begin{columns}[t]

    \begin{column}{.5\textwidth}
      \begin{codeblock}<2->{
struct LessThan42 \{
  auto operator()(int n)
  \{
    return n < 42;
  \}
\};

class LessThan \{
  int m\_;
 public:
  explicit LessThan(int m)
    : m\_\{m\} \{\}
  auto operator()(int n) const
  \{
    return n < m_;
  \}
\};}\end{codeblock}

    \end{column}

    \begin{column}{.5\textwidth}
      \begin{codeblock}<2->{
find_if(\ldots, LessThan42\{\});

\uncover<3->{find_if(\ldots, \alert<3>{[](int n) \{}
               return n < 42;
             \alert<3>{\}}
);}

find_if(\ldots, LessThan\{m\});

\uncover<4->{\only<4>{\alert{int m = \ddd;}}
find_if(\ldots, [\alert<4->{\only<4>{=}\only<5>{m = \ddd}}](int n) \{
              return n < \alert<4->{m};
             \}
);}}\end{codeblock}
    \end{column}

  \end{columns}
\end{frame}

\begin{frame}[fragile]{Lambda closure}
  The evaluation of a lambda expression produces an unnamed function object (a
  \textit{closure})
  \begin{itemize}
  \item The \texttt{operator()} corresponds to the code of the body of the
    lambda expression
  \item The data members are the captured local variables
  \end{itemize}

  \vskip -3mm

  \begin{columns}[t]
    \begin{column}{.5\textwidth}
      \begin{codeblock}<2->{
\uncover<4-6>{int v = 42;}

\uncover<2->{auto lt = [}\temporal<5-6>{}{=}{v = 42}\uncover<2->{]}\uncover<3->{(\alt<-7>{int }{auto} n)\uncover<9->{ -> bool}
           \{ return n < v; \}}

\uncover<6->{auto r = lt(5); // true}}\end{codeblock}

      \uncover<7>{}
    \end{column}

    \begin{column}{.5\textwidth}
      \begin{codeblock}<2->{
\uncover<2->{class SomeUniqueName \{
  \uncover<5->{int v\_;}
 public:
  \uncover<5->{explicit SomeUniqueName(int v)
    : v\_\{v\} \{\}}
  \uncover<8->{template<typename T>}
  \alt<-8>{auto}{bool } operator()\uncover<3->{(\alt<-7>{int}{T  } n)} const
  \uncover<3->{\{ return n < v\uncover<5->{\_}; \}}
\};}

\uncover<4->{int v = 42;}
\uncover<2->{auto lt = SomeUniqueName\{}\uncover<5->{v}\uncover<2->{\};}
\uncover<6->{auto r = lt(5); // true}}\end{codeblock}
    \end{column}
  \end{columns}

  \begin{itemize}
  \item<10-> Each lambda is of a different type
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{Lambda capture}

  \begin{itemize}
  \item Automatic variables used in the body of the lambda need to be captured
    \begin{itemize}
    \item<2-> \texttt{[]} capture nothing
    \item<2-> \texttt{[=]} capture all (what is needed) by value
    \item<2-> \texttt{[k]} capture \texttt{k} by value
    \item<3-> \texttt{[\&]} capture all (what is needed) by reference
    \item<3-> \texttt{[\&k]} capture \texttt{k} by reference
    \item<4-> \texttt{[=, \&k]} capture all by value but \texttt{k} by reference
    \item<4-> \texttt{[\&, k]} capture all by reference but \texttt{k} by value
    \end{itemize}

    \vskip -3mm

    \begin{columns}[T]
      \begin{column}{.5\textwidth}
        \begin{codeblock}<2->{
int v = 3;
auto lam = [\only<3->{\alert<3>{&}}v] \{\};}\end{codeblock}
      \end{column}

      \begin{column}{.5\textwidth}
        \begin{codeblock}<2->{
class SomeUniqueName \{
  int\only<3->{\alert<3>{&}} v\_;
 public:
  explicit SomeUniqueName(int\only<3->{\alert<3>{&}} v)
    : v\_\{v\} \{\}
  \ddd
\};

auto lam = SomeUniqueName\{v\};}\end{codeblock}
      \end{column}
    \end{columns}

  \item<5-> Global variables are available without being captured
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Lambda: \texttt{const} and \texttt{mutable}}
  \begin{itemize}
  \item By default the call to a lambda is \texttt{const}
    \begin{itemize}
    \item Variables captured by value are not modifiable
    \end{itemize}
  \item<2-> A lambda can be declared \texttt{mutable}
    \begin{itemize}
    \item The parameter list is mandatory
    \end{itemize}
  \item<3-> If present, the explicit return type goes after \code{mutable}
  \end{itemize}

  \begin{columns}[T]
    \begin{column}{.5\textwidth}
      \begin{codeblock}<1->{
[]\only<2->{\alert<2>{() mutable}}\only<3->{\alert<3>{ -> void}} \{\};}\end{codeblock}
    \end{column}

    \begin{column}{.5\textwidth}
      \begin{codeblock}<1->{
struct SomeUniqueName \{
  \alt<-2>{auto}{\alert<3>{void}} operator()() \only<1>{\alert{const} }\{\}
\};}\end{codeblock}
    \end{column}
  \end{columns}

  \begin{itemize}
  \item<4-> Variables captured by reference can be modified
    \begin{itemize}
    \item There is no way to capture by \texttt{const\&}
    \end{itemize}
  \end{itemize}

  \begin{codeblock}<4->
int v = 3;
[\&v] \{ ++v; \}(); // note how the lamdba is immediately executed
assert(v == 4);\end{codeblock}

\end{frame}

\begin{frame}[fragile]{Lambda: dangling reference}

  \begin{itemize}
  \item Be careful not to have dangling references in a closure
  \item It's similar to a function returning a reference to a local variable

  \begin{codeblock}
auto make\_lambda() // auto here is unavoidable
\{
  int v = 3;
  return [\alert{&}] \{ return v; \}; // return a closure
\}

auto lam = make\_lambda();
auto d = lam(); // the captured variable is dangling here\end{codeblock}

  \item<2-> Capture by reference only if the lambda doesn't survive the current
    scope
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{\texttt{std::function}}

  \begin{itemize}
  \item Type-erased wrapper that can store and invoke any callable entity with a
    certain signature
    \begin{itemize}
    \item function, function object, lambda, member function
    \end{itemize}

    \begin{codeblock}<2->{
#include <functional>

using Function = std::function<\alert{int(int,int)}>; // \alert{signature}

Function f1 \{ std::plus<int>\{\} \};
Function f2 \{ [](int a, int b) \{ return a * b; \} \};
Function f3 \{ [](auto a, auto b) \{ return std::gcd(a,b); \} \};}\end{codeblock}

  \item<3-> Some space and time overhead, so use only if a template parameter is
    not satisfactory
    \begin{codeblock}<4->{
std::vector<Function> functions \{ f1, f2, f3 \};

for (auto& f : functions) \{
  std::cout << f(121, 42) << \bslashn; // 163 5082 1
\}}\end{codeblock}

  \end{itemize}

\end{frame}
